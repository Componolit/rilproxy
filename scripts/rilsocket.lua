-- This is Wireshark/tshark packet dissector for RILd messages. Place it into
-- your local plugin directory (e.g. $HOME/.wireshark/plugins/)

-- Load ril.h definitions generated by scripts/parse_ril_h.py
-- Place the resulting file as ril_h.lua into your plugin directory
local ril_h = require 'ril_h'

-- Inset custom rilproxy requests
REQUEST_SETUP = 0xc715
REQUEST[REQUEST_SETUP] = "SETUP"

REQUEST_TEARDOWN = 0xc717
REQUEST[REQUEST_TEARDOWN] = "TEARDOWN"

local rilproxy = Proto("rild", "RILd socket");
local ril_log = ''

-- Register expert info fields
local rild_error = ProtoExpert.new("rild.error", "Error decoding RIL message", expert.group.MALFORMED, expert.severity.ERROR)
rilproxy.experts = { rild_error }

-----------------------------------------------------------------------------------------------------------------------
-- Helper functions
-----------------------------------------------------------------------------------------------------------------------
function parse_int_list(buffer)
    local result = {}
    assert(buffer:len() > 3)
    local len = buffer:range(0,4):le_uint()
    assert(4 * len + 4 <= buffer:len())
    for i = 1, len
    do
        table.insert(result, buffer:range(4*i, 4):le_uint())
    end
    return result
end

function parse_string(buffer)

    assert(buffer:len() > 3)
    local len = buffer:range(0,4):le_uint()

    --  Null string is represented as len=0xffffffff.
    if len == 0xffffffff
    then
        return 4, nil
    end

    -- The len values stored in the first 4 bytes of the buffer
    -- denotes the length in *characters*. Every character allocates
    -- 2 bytes of space and is stored in little-endian byte order.
    -- The storage size of the string in bytes is rounded up to the
    -- next multiple of 4 bytes such that space is availble for an
    -- additional trailing null-character (2 bytes).
    local string_len = 4 + 4 * math.ceil ((len + 1) / 2)

    assert(string_len <= buffer:len(), "len=" .. len .. ", expectd >= " .. string_len)

    local result = ""
    for i=4,2*len+2,2
    do
        result = result .. string.char(buffer:range(i,2):le_uint())
    end

    return string_len, result
end

function parse_stringlist(buffer)

    assert(buffer:len() > 3)
    local len = buffer:range(0,4):le_uint()
    local start = 4

    results = {}
    for i=1,len
    do
        len, data = parse_string(buffer(start,-1))
        table.insert(results, {len=len, data=data})
        start = start + len
    end
    return results
end

function parse_bytes(buffer)

    assert(buffer:len() > 3)
    local len = buffer:range(0,4):le_uint()
    assert(len <= buffer:len(), "len=" .. buffer:len() .. ", expectd >= " .. len)

    local padded_len = 4 * math.floor((len + 3) / 4) + 4

    return padded_len, buffer:range(4,len)
end

--  Represent nil value as <NULL> string
function nil_repr(value)

    if value == nil
    then
        return '<NULL>'
    end

    return value
end

--  Convert string to int, return 0xffffffff if input is nil
function to_int(text)
    if text == nil
    then
        return 0xffffffff
    end
    return tonumber(text)
end

-- Add an little-endian integer from 'buffer' to a 'field' in 'tree'.
-- The value is addeded only if it is within first..last and does
-- not equal 'invalid'. Otherwise the strings 'INVALID' or 'OUT OF BOUNDS'
-- are added respectively.
function add_le_with_domain(tree, field, buffer, first, last, invalid)
    local value = buffer:le_int()

    if value == invalid
    then
        tree:add(field, buffer, "INVALID (" .. tostring(value) .. ")")
        return
    end

    if value < first or value > last
    then
        tree:add(field, buffer, "OUT OF BOUNDS (" .. tostring(value) .. ")")
        return
    end

    tree:add(field, buffer, tostring(value))
end

function log(message)
    ril_log = ril_log .. message .. "<br>"
end

-----------------------------------------------------------------------------------------------------------------------
-- hexdump dissector
-----------------------------------------------------------------------------------------------------------------------
local rild_content = Proto("rild.content", "Hexdump content");

rild_content.fields.content = ProtoField.bytes("rild.hexdump", "Hexdump", base.HEX)

function rild_content.dissector(buffer, info, tree)
    if buffer:len() > 0
    then
        tree:add(rild_content.fields.content, buffer:range(0,-1))
        info.cols.info:append(" *** ")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- UNSOL(RIL_CONNECTED) dissector
-----------------------------------------------------------------------------------------------------------------------
local unsol_ril_connected = Proto("rild.unsol.ril_connected", "RIL_CONNECTED");

unsol_ril_connected.fields.version = ProtoField.uint32('rild.unsol_ril_connected.version', 'RIL version', base.DEC)

function unsol_ril_connected.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add_le(unsol_ril_connected.fields.version, buffer:range(4,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- UNSOL(OEM_HOOK_RAW) dissector
-----------------------------------------------------------------------------------------------------------------------

local unsol_oem_hook_raw = Proto("rild.unsol.oem_hook_raw", "OEM_HOOK_RAW");

unsol_oem_hook_raw.fields.data =
    ProtoField.bytes('rild.unsol.oem_hook_raw.data', 'Data', base.HEX)

function unsol_oem_hook_raw.dissector(buffer, info, tree)
    len, data = parse_bytes(buffer)
    tree:add(unsol_oem_hook_raw.fields.data, buffer:range(0,len))
end

-----------------------------------------------------------------------------------------------------------------------
-- UNSOL(RESPONSE_RADIO_STATE_CHANGED) dissector
-----------------------------------------------------------------------------------------------------------------------

local unsol_response_radio_state_changed = Proto("rild.unsol.response_radio_state_changed", "RESPONSE_RADIO_STATE_CHANGED");

-- According to ril.h, RESPONSE_RADIO_STATE_CHANGED has no data payload.
-- However, older RIL.java sources mention that is "has bonus radio state int" which is casted into RadioState.
-- Try to extract and convert this additional field.
unsol_response_radio_state_changed.fields.version =
    ProtoField.uint32('rild.unsol.response_radio_state_changed.state', 'Radio state', base.DEC, RADIOSTATE)

function unsol_response_radio_state_changed.dissector(buffer, info, tree)
    if buffer:len() > 3
    then
        tree:add_le(unsol_response_radio_state_changed.fields.version, buffer:range(0,4))
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- UNSOL(SIGNAL_STRENGTH) dissector
-----------------------------------------------------------------------------------------------------------------------

local gw_signal_strength = Proto("rild.gw_signal_strength", "GW SignalStrength");

gw_signal_strength.fields.signalstrength =
    ProtoField.string('rild.gw_signal_strength.signalstrength', 'Signal strength', base.DEC)

gw_signal_strength.fields.biterrorrate =
    ProtoField.string('rild.gw_signal_strength.biterrorrate', 'Bit error rate', base.DEC)

function gw_signal_strength.dissector(buffer, info, tree)
    add_le_with_domain(tree, gw_signal_strength.fields.signalstrength, buffer:range(0,4), 0, 31, 99)
    add_le_with_domain(tree, gw_signal_strength.fields.biterrorrate, buffer:range(4,4), 0, 7, 99)
end

-----------------------------------------------------------------------------------------------------------------------

local cdma_signal_strength = Proto("rild.cdma_signal_strength", "CDMA SignalStrength");

cdma_signal_strength.fields.dbm =
    ProtoField.string('rild.cdma_signal_strength.dbm', 'RSSI', base.DEC)

cdma_signal_strength.fields.ecio =
    ProtoField.string('rild.cdma_signal_strength.ecio', 'Ec/Io', base.DEC)

function cdma_signal_strength.dissector(buffer, info, tree)
    add_le_with_domain(tree, cdma_signal_strength.fields.dbm, buffer:range(0,4), 0, 0xfffffffe, 0xffffffff)
    add_le_with_domain(tree, cdma_signal_strength.fields.ecio, buffer:range(4,4), 0, 0xfffffffe, 0xffffffff)
end

-----------------------------------------------------------------------------------------------------------------------

local evdo_signal_strength = Proto("rild.evdo_signal_strength", "EVDO SignalStrength");

evdo_signal_strength.fields.signalnoiseratio =
    ProtoField.string('rild.evdo_signal_strength.signalnoiseratio', 'SNI', base.DEC)

function evdo_signal_strength.dissector(buffer, info, tree)
    cdma_signal_strength.dissector:call(buffer(0,8):tvb(), info, tree)
    add_le_with_domain(tree, evdo_signal_strength.fields.signalnoiseratio, buffer:range(8,4), 0, 8, 0xffffffff)
end

-----------------------------------------------------------------------------------------------------------------------

local lte_signal_strength = Proto("rild.lte_signal_strength", "LTE SignalStrength");

lte_signal_strength.fields.signalstrength =
    ProtoField.string('rild.lte_signal_strength.signalstrength', 'Signal strength', base.DEC)
lte_signal_strength.fields.rsrp =
    ProtoField.string('rild.lte_signal_strength.rsrp', 'RSRP', base.DEC)
lte_signal_strength.fields.rsrq =
    ProtoField.string('rild.lte_signal_strength.rsrq', 'RSRQ', base.DEC)
lte_signal_strength.fields.rssnr =
    ProtoField.string('rild.lte_signal_strength.rssnr', 'RSSNR', base.DEC)
lte_signal_strength.fields.cqi =
    ProtoField.string('rild.lte_signal_strength.cqi', 'CQI', base.DEC)
lte_signal_strength.fields.timingadvance =
    ProtoField.string('rild.lte_signal_strength.timingadvance', 'Timing advance', base.DEC)

function lte_signal_strength.dissector(buffer, info, tree)
    add_le_with_domain(tree, lte_signal_strength.fields.rsrp, buffer:range(0,4), 0, 31, 99)
    add_le_with_domain(tree, lte_signal_strength.fields.rsrp, buffer:range(4,4), 44, 140, 0x7fffffff)
    add_le_with_domain(tree, lte_signal_strength.fields.rsrq, buffer:range(8,4), 3, 20, 0x7fffffff)
    add_le_with_domain(tree, lte_signal_strength.fields.rssnr, buffer:range(12,4), -200, 300, 0x7fffffff)
    add_le_with_domain(tree, lte_signal_strength.fields.cqi, buffer:range(16,4), 0, 15, 0x7fffffff)
end

-----------------------------------------------------------------------------------------------------------------------

local unsol_signal_strength = Proto("rild.unsol.signal_strength", "SIGNAL_STRENGTH");

--
-- There are multiple version of RIL_SignalStrength_v?? type. We can distinguish
-- them by their size:
--
-- RIL_SignalStrength_v5:  28
-- RIL_SignalStrength_v6:  48
-- RIL_SignalStrength_v8:  52
-- RIL_SignalStrength_v10: 56
--

unsol_signal_strength.fields.version =
    ProtoField.uint32('rild.unsol.signal_strength.state', 'Radio state', base.DEC, RADIOSTATE)

unsol_signal_strength.fields.timingadvance =
    ProtoField.string('rild.unsol.signal_strength.timingadvance', 'Timing advance')

unsol_signal_strength.fields.rscp =
    ProtoField.uint32('rild.unsol.signal_strength.rscp', 'Received signal code power', base.DEC)

function unsol_signal_strength.dissector(buffer, info, tree)
    if buffer:len() < 28
    then
        return
    end

    local gw_subtree = tree:add(gw_signal_strength, buffer(0,8))
    gw_signal_strength.dissector:call(buffer(0,8):tvb(), info, gw_subtree)
    local cdma_subtree = tree:add(cdma_signal_strength, buffer(8,8))
    cdma_signal_strength.dissector:call(buffer(8,8):tvb(), info, cdma_subtree)
    local evdo_subtree = tree:add(evdo_signal_strength, buffer(16,12))
    evdo_signal_strength.dissector:call(buffer(16,12):tvb(), info, evdo_subtree)

    if buffer:len() > 28
    then
        local lte_subtree = tree:add(lte_signal_strength, buffer(28,20))
        lte_signal_strength.dissector:call(buffer(28,20):tvb(), info, lte_subtree)

        if buffer:len() > 48
        then
            add_le_with_domain(lte_subtree, unsol_signal_strength.fields.timingadvance, buffer:range(48,4), 0, 0x7ffffffe, 0x7fffffff)

            if buffer:len() > 52
            then
                add_le_with_domain(lte_subtree, unsol_signal_strength.fields.rscp, buffer:range(52,4), 25, 120, 0x7fffffff)
            end
        end
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(RADIO_POWER) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_radio_power = Proto("rild.request.radio_power", "REQUEST_RADIO_POWER");

-- FIXME: 'on' actually means > 0
RADIO_POWER = {
    [0] = "OFF",
    [1] = "ON"
}

request_radio_power.fields.power =
    ProtoField.uint32('rild.request.radio_power.power', 'Radio power', base.DEC, RADIO_POWER)

function request_radio_power.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add(request_radio_power.fields.power, buffer:range(4,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(SCREEN_STATE) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_screen_state = Proto("rild.request.screen_state", "REQUEST_SCREEN_STATE");

SCREEN_STATE = {
    [0] = "OFF",
    [1] = "ON"
}

request_screen_state.fields.screenstate =
    ProtoField.uint32('rild.request.screen_state.screenstate', 'Screen state', base.DEC, SCREEN_STATE)

function request_screen_state.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add_le(request_screen_state.fields.screenstate, buffer:range(4,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(SIM_OPEN_CHANNEL) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_sim_open_channel = Proto("rild.request.sim_open_channel", "REQUEST_SIM_OPEN_CHANNEL");

request_sim_open_channel.fields.aid_len =
    ProtoField.uint32('rild.request.sim_open_channel.aid_len', 'Length', base.DEC)

request_sim_open_channel.fields.aid =
    ProtoField.string('rild.request.sim_open_channel.aid', 'Value', base.STRING)

function request_sim_open_channel.dissector(buffer, info, tree)
    local text
    local len, value = parse_string(buffer)
    value = nil_repr(value)

    --  Values according to https://source.android.com/devices/tech/config/uicc
    if value == "A00000015141434C00"
    then
        text = 'Access Rule Applet ("'
    elseif value == "A000000063504B43532D3135"
    then
        text = 'PKCS15 ("'
    else
        text = 'INVALID ("'
    end
    text = text .. value .. '")'

    subtree:add(request_sim_open_channel.fields.aid, buffer(0, len), text)
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(CDMA_SET_SUBSCRIPTION_SOURCE) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_cdma_set_subscription_source = Proto("rild.request.cdma_set_subscription_source", "REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE");

request_cdma_set_subscription_source.fields.subscription =
    ProtoField.uint32('rild.request.cdma_set_subscription_source.fields.subscription', 'Subscription source', base.DEC, CDMASUBSCRIPTIONSOURCE)

function request_cdma_set_subscription_source.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add(request_cdma_set_subscription_source.fields.subscription, buffer:range(4,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(SET_UNSOL_CELL_INFO_LIST_RATE) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_set_unsol_cell_info_list_rate = Proto("rild.request.set_unsol_cell_info_list_rate", "SET_UNSOL_CELL_INFO_LIST_RATE");

request_set_unsol_cell_info_list_rate.fields.rate_ms =
    ProtoField.uint32('rild.request.set_unsol_cell_info_list_rate.fields.rate_ms', 'Rate [ms]', base.DEC)
request_set_unsol_cell_info_list_rate.fields.rate =
    ProtoField.string('rild.request.set_unsol_cell_info_list_rate.fields.rate', 'Rate')

function request_set_unsol_cell_info_list_rate.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        if (values[1] == 0)
        then
            -- Invoke UNSOL(CELL_INFO_LIST) when information changes
            tree:add(request_set_unsol_cell_info_list_rate.fields.rate, buffer:range(4,4), "ON CHANGE")
        elseif (values[1] == 0x7fffffff)
        then
            -- Never invoke UNSOL(CELL_INFO_LIST)
            tree:add(request_set_unsol_cell_info_list_rate.fields.rate, buffer:range(4,4), "NEVER")
        else
            -- Invoke UNSOL(CELL_INFO_LIST) every n milli-seconds
            tree:add_le(request_set_unsol_cell_info_list_rate.fields.rate_ms, buffer:range(4,4))
        end
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(START_LCE) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_start_lce = Proto("rild.request.start_lce", "REQUEST_START_LCE");

request_start_lce.fields.reportinginterval =
    ProtoField.uint32('rild.request.start_lce.fields.reportinginterval', 'Reporting interval [ms]', base.DEC)

LCE_SERVICE_MODE_PUSH = 0
LCE_SERVICE_MODE_PULL = 1

LCE_SERVICE_MODE = {
    [LCE_SERVICE_MODE_PUSH] = "PUSH",
    [LCE_SERVICE_MODE_PULL] = "PULL"
}

request_start_lce.fields.servicemode =
    ProtoField.uint32('rild.request.start_lce.fields.servicemode', 'Service mode', base.DEC, LCE_SERVICE_MODE)

function request_start_lce.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 2
    then
        tree:add(request_start_lce.fields.reportinginterval, buffer:range(4,4), values[1])
        tree:add(request_start_lce.fields.servicemode, buffer:range(8,4), values[2])
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 2 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(SIM_IO) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_sim_io = Proto("rild.request.sim_io", "REQUEST_SIM_IO");

CRSMCOMMAND_READ_BINARY = 176
CRSMCOMMAND_READ_RECORD = 178
CRSMCOMMAND_GET_RESPONSE = 192
CRSMCOMMAND_UPDATE_BINARY = 214
CRSMCOMMAND_UPDATE_RECORD = 220
CRSMCOMMAND_STATUS = 242
CRSMCOMMAND_RETRIEVE_DATA = 203
CRSMCOMMAND_SET_DATA = 219

CRSMCOMMAND = {
    [CRSMCOMMAND_READ_BINARY]   = "READ_BINARY",
    [CRSMCOMMAND_READ_RECORD]   = "READ_RECORD",
    [CRSMCOMMAND_GET_RESPONSE]  = "GET_RESPONSE",
    [CRSMCOMMAND_UPDATE_BINARY] = "UPDATE_BINARY",
    [CRSMCOMMAND_UPDATE_RECORD] = "UPDATE_RECORD",
    [CRSMCOMMAND_STATUS]        = "STATUS",
    [CRSMCOMMAND_RETRIEVE_DATA] = "RETRIEVE_DATA",
    [CRSMCOMMAND_SET_DATA]      = "SET_DATA"
}

request_sim_io.fields.command =
    ProtoField.uint32('rild.request.sim_io.fields.command', 'Command', base.DEC, CRSMCOMMAND)

request_sim_io.fields.fileid =
    ProtoField.uint32('rild.request.sim_io.fields.file_id', 'File ID', base.HEX)

request_sim_io.fields.path =
    ProtoField.string('rild.request.sim_io.fields.path', 'Path', base.STRING)

request_sim_io.fields.p1 =
    ProtoField.uint32('rild.request.sim_io.fields.p1', 'P1', base.HEX)

request_sim_io.fields.p2 =
    ProtoField.uint32('rild.request.sim_io.fields.p2', 'P2', base.HEX)

request_sim_io.fields.p3 =
    ProtoField.uint32('rild.request.sim_io.fields.p3', 'P3', base.HEX)

request_sim_io.fields.data =
    ProtoField.string('rild.request.sim_io.fields.data', 'Data', base.STRING)

request_sim_io.fields.pin2 =
    ProtoField.string('rild.request.sim_io.fields.pin2', 'PIN2', base.STRING)

request_sim_io.fields.aid =
    ProtoField.string('rild.request.sim_io.fields.aid', 'AID', base.STRING)

function request_sim_io.dissector(buffer, info, tree)
    tree:add_le(request_sim_io.fields.command, buffer:range(0,4))
    tree:add_le(request_sim_io.fields.fileid, buffer:range(4,4))

    local path_len, path = parse_string(buffer(8,-1))
    tree:add(request_sim_io.fields.path, buffer(8, path_len), '"' .. nil_repr(path) .. '"')

    local path_end = 8 + path_len
    tree:add_le(request_sim_io.fields.p1, buffer:range(path_end,4))
    tree:add_le(request_sim_io.fields.p2, buffer:range(path_end + 4,4))
    tree:add_le(request_sim_io.fields.p3, buffer:range(path_end + 8,4))

    local data_len, data = parse_string(buffer(path_end + 12,-1))
    tree:add(request_sim_io.fields.data, buffer(path_end + 12, data_len), '"' .. nil_repr(data) .. '"')

    local data_end = path_end + 12 + data_len
    local pin2_len, pin2 = parse_string(buffer(data_end, -1))
    tree:add(request_sim_io.fields.data, buffer(data_end, pin2_len), '"' .. nil_repr(pin2) .. '"')

    local pin2_end = data_end + pin2_len
    if pin2_end + 4 <= buffer:len()
    then
        local aid_len, aid = parse_string(buffer(pin2_end, -1))
        tree:add(request_sim_io.fields.aid, buffer(pin2_end, aid_len), '"' .. nil_repr(aid) .. '"')
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(DATA_REGISTRATION_STATE) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_data_registration_state = Proto("rild.reply.data_registration_state", "REPLY_DATA_REGISTRATION_STATE");

reply_data_registration_state.fields.regstate =
    ProtoField.uint32('rild.reply.data_registration_state.regstate', 'Registration state', base.DEC, REGSTATE)

reply_data_registration_state.fields.lac =
    ProtoField.string('rild.reply.data_registration_state.lac', 'LAC', base.STRING)

reply_data_registration_state.fields.cid =
    ProtoField.string('rild.reply.data_registration_state.cid', 'CID', base.STRING)

reply_data_registration_state.fields.rat =
    ProtoField.string('rild.reply.data_registration_state.rat', 'RAT', base.STRING)

-- FIXME: Not used at the moment. Convert strings to numeric values.
DATA_DENIED_REASON_GPRS_SERVICE_NOT_ALLOWED = 7
DATA_DENIED_REASON_GPRS_SERVICE_AND_NON_GPRS_SERVICE_NOT_ALLOWED = 8
DATA_DENIED_REASON_MS_IDENTITY_CANNOT_BE_DERIVED = 9
DATA_DENIED_REASON_IMPLICITLY_DETACHED = 10
DATA_DENIED_REASON_GPRS_SERVICE_NOT_ALLOWED_IN_THIS_PLMN = 14
DATA_DENIED_REASON_MSC_TEMPORARILY_NOT_REACHABLE = 16
DATA_DENIED_REASON_NO_PDP_CONTEXT_ACTIVATED = 40

DATA_DENIED_REASON = {
    [DATA_DENIED_REASON_GPRS_SERVICE_NOT_ALLOWED] = "GPRS services not allowed",
    [DATA_DENIED_REASON_GPRS_SERVICE_AND_NON_GPRS_SERVICE_NOT_ALLOWED] = "GPRS services and non-GPRS services not allowed",
    [DATA_DENIED_REASON_MS_IDENTITY_CANNOT_BE_DERIVED] = "MS identity cannot be derived by the network",
    [DATA_DENIED_REASON_IMPLICITLY_DETACHED] = "Implicitly detached",
    [DATA_DENIED_REASON_GPRS_SERVICE_NOT_ALLOWED_IN_THIS_PLMN] = "GPRS services not allowed in this PLMN",
    [DATA_DENIED_REASON_MSC_TEMPORARILY_NOT_REACHABLE] = "MSC temporarily not reachable",
    [DATA_DENIED_REASON_NO_PDP_CONTEXT_ACTIVATED] = "No PDP context activated"
}

reply_data_registration_state.fields.reasondatadenied =
    ProtoField.uint32('rild.reply.data_registration_state.reasondatadenied', 'Data-denied reason', base.DEC, DATA_DENIED_REASON)

reply_data_registration_state.fields.maxdatacalls =
    ProtoField.uint32('rild.reply.data_registration_state.maxdatacalls', 'Maximum data calls', base.DEC)

reply_data_registration_state.fields.ltetac =
    ProtoField.string('rild.reply.data_registration_state.ltetac', 'LTE TAC', base.STRING)

reply_data_registration_state.fields.ltecid =
    ProtoField.string('rild.reply.data_registration_state.ltecid', 'LTE CID', base.STRING)

reply_data_registration_state.fields.lteeci =
    ProtoField.string('rild.reply.data_registration_state.lteeci', 'LTE ECI', base.STRING)

reply_data_registration_state.fields.ltecsgid =
    ProtoField.string('rild.reply.data_registration_state.ltecsgid', 'LTE CSGID', base.STRING)

reply_data_registration_state.fields.ltetadv =
    ProtoField.string('rild.reply.data_registration_state.ltetadv', 'LTE TADV', base.STRING)

function reply_data_registration_state.dissector(buffer, info, tree)
    local results = parse_stringlist(buffer)
    if #results >= 6
    then
        start = 4
        tree:add(reply_data_registration_state.fields.regstate, buffer(start, results[1].len), to_int(results[1].data))
        start = start + results[1].len
        tree:add(reply_data_registration_state.fields.lac, buffer(start, results[2].len), nil_repr(results[2].data))
        start = start + results[2].len
        tree:add(reply_data_registration_state.fields.cid, buffer(start, results[3].len), nil_repr(results[3].data))
        start = start + results[3].len
        tree:add(reply_data_registration_state.fields.rat, buffer(start, results[4].len), nil_repr(results[4].data))
        start = start + results[4].len
        tree:add(reply_data_registration_state.fields.reasondatadenied, buffer(start, results[5].len), to_int(results[5].data))
        start = start + results[5].len
        tree:add(reply_data_registration_state.fields.maxdatacalls, buffer(start, results[6].len), to_int(results[6].data))

        if #results >= 11
        then
            start = start + results[6].len
            tree:add(reply_data_registration_state.fields.ltetac, buffer(start, results[7].len), nil_repr(results[7].data))
            start = start + results[7].len
            tree:add(reply_data_registration_state.fields.ltecid, buffer(start, results[8].len), nil_repr(results[8].data))
            start = start + results[8].len
            tree:add(reply_data_registration_state.fields.lteeci, buffer(start, results[9].len), nil_repr(results[9].data))
            start = start + results[9].len
            tree:add(reply_data_registration_state.fields.ltecsgid, buffer(start, results[10].len), nil_repr(results[10].data))
            start = start + results[10].len
            tree:add(reply_data_registration_state.fields.ltetadv, buffer(start, results[11].len), nil_repr(results[11].data))
        end
    else
        tree:add_tvb_expert_info(reply_data_registration_state.fields.regstate, buffer, "Expected string list with 11 element (got " .. #results .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(QUERY_NETWORK_SELECTION_MODE) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_query_network_selection_mode = Proto("rild.reply.query_network_selection_mode", "QUERY_NETWORK_SELECTION_MODE");

SELECTION_AUTOMATIC = 0
SELECTION_MANUAL = 1
SELECTION = {
    [SELECTION_AUTOMATIC] = "AUTOMATIC",
    [SELECTION_MANUAL] = "MANUAL"
}

reply_query_network_selection_mode.fields.selection =
    ProtoField.uint32('rild.reply.reply_query_network_selection_mode.selection', 'Selection mode', base.DEC, SELECTION)

function reply_query_network_selection_mode.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add_le(reply_query_network_selection_mode.fields.selection, buffer:range(4,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(BASEBAND_VERSION) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_baseband_version = Proto("rild.reply.baseband_version", "BASEBAND_VERSION");

reply_baseband_version.fields.version =
    ProtoField.string('rild.reply.reply_baseband_version.version', 'Baseband version', base.STRING)

function reply_baseband_version.dissector(buffer, info, tree)
    local len, string = parse_string(buffer)
    tree:add(reply_baseband_version.fields.version, buffer:range(0, len), '"' .. nil_repr(string) .. '"')
end
-----------------------------------------------------------------------------------------------------------------------
-- REPLY(OPERATOR) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_operator = Proto("rild.reply.operator", "OPERATOR");

reply_operator.fields.long_alpha_ons =
    ProtoField.string('rild.reply.reply_operator.long_alpha_ons', 'Long alpha ONS or EONS', base.STRING)

reply_operator.fields.short_alpha_ons =
    ProtoField.string('rild.reply.reply_operator.short_alpha_ons', 'Short alpha ONS or EONS', base.STRING)

reply_operator.fields.mcc_mnc =
    ProtoField.string('rild.reply.reply_operator.mcc_mnc', 'MCC/MNC', base.STRING)

function reply_operator.dissector(buffer, info, tree)
    local results = parse_stringlist(buffer)
    tree:add(reply_operator.fields.long_alpha_ons, buffer(4, results[1].len), results[1].data)
    tree:add(reply_operator.fields.short_alpha_ons, buffer(4 + results[1].len, results[2].len), results[2].data)
    tree:add(reply_operator.fields.mcc_mnc, buffer(4 + results[1].len + results[2].len, results[3].len), results[3].data)
    -- FIXME: The traces I saw had 6 strings - investigate what the remaining 3 are good for.
end


-----------------------------------------------------------------------------------------------------------------------
-- REPLY(GET_IMEI) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_get_imei = Proto("rild.reply.get_imei", "GET_IMEI");

reply_get_imei.fields.imei =
    ProtoField.string('rild.reply.reply_get_imei.imei', 'IMEI', base.STRING)

function reply_get_imei.dissector(buffer, info, tree)
    local len, string = parse_string(buffer)
    tree:add(reply_get_imei.fields.imei, buffer:range(0, len), '"' .. nil_repr(string) .. '"')
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(GET_IMEISV) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_get_imeisv = Proto("rild.reply.get_imeisv", "GET_IMEISV");

reply_get_imeisv.fields.imeisv =
    ProtoField.string('rild.reply.reply_get_imeisv.imeisv', 'IMEISV', base.STRING)

function reply_get_imeisv.dissector(buffer, info, tree)
    local len, string = parse_string(buffer)
    tree:add(reply_get_imeisv.fields.imeisv, buffer:range(0, len), '"' .. nil_repr(string) .. '"')
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(START_LCE) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_start_lce = Proto("rild.reply.start_lce", "START_LCE");

LCE_STATUS_INFO_NOT_SUPPORTED = 255
LCE_STATUS_INFO_STOPPED = 0
LCE_STATUS_INFO_ACTIVE = 1

LCE_STATUS_INFO = {
    [LCE_STATUS_INFO_NOT_SUPPORTED] = "NOT SUPPORTED",
    [LCE_STATUS_INFO_STOPPED] = "STOPPED",
    [LCE_STATUS_INFO_ACTIVE] = "ACTIVE"
}

reply_start_lce.fields.status=
    ProtoField.uint32('rild.reply.start_lce.status', 'Status', base.DEC, LCE_STATUS_INFO)

reply_start_lce.fields.interval =
    ProtoField.uint32('rild.reply.start_lce.interval', 'Actual interval [ms]', base.DEC)

function reply_start_lce.dissector(buffer, info, tree)
    tree:add_le(reply_start_lce.fields.status, buffer:range(0, 4))
    tree:add_le(reply_start_lce.fields.interval, buffer:range(4, 4))
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(VOICE_RADIO_TECH) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_voice_radio_tech = Proto("rild.reply.voice_radio_tech", "VOICE_RADIO_TECH");

reply_voice_radio_tech.fields.radiotechnology =
    ProtoField.uint32('rild.reply.reply_voice_radio_tech.radiotechnology', 'Radio technology', base.DEC, RADIOTECHNOLOGY)

function reply_voice_radio_tech.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add_le(reply_voice_radio_tech.fields.radiotechnology, buffer:range(4,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- RILd dissector
-----------------------------------------------------------------------------------------------------------------------
local src_ip_addr_f = Field.new("ip.src")
local dst_ip_addr_f = Field.new("ip.dst")

MTYPE_REPLY = 0
MTYPE_UNSOL = 1

MTYPE = {
    [MTYPE_REPLY] = "REPLY",
    [MTYPE_UNSOL] = "UNSOL"
}

DIR_UNKNOWN = 0
DIR_FROM_AP = 1
DIR_FROM_BP = 2

DirectionLabel = {
    [DIR_UNKNOWN] = "[??->??]",
    [DIR_FROM_AP] = "[AP->BP]",
    [DIR_FROM_BP] = "[BP->AP]"
}

rilproxy.fields.length  = ProtoField.uint32('rilproxy.length', 'Length', base.DEC)
rilproxy.fields.request = ProtoField.uint32('rilproxy.request', 'Request', base.DEC, REQUEST)
rilproxy.fields.mtype   = ProtoField.uint32('rilproxy.mtype', 'Type', base.DEC, MTYPE)
rilproxy.fields.token   = ProtoField.uint32('rilproxy.token', 'Token', base.HEX)
rilproxy.fields.reply   = ProtoField.framenum('rilproxy.reply', 'In reply to frame', base.NONE, frametype.RESPONSE)
rilproxy.fields.result  = ProtoField.uint32('rilproxy.result', 'Result', base.DEC, ERRNO)
rilproxy.fields.event   = ProtoField.uint32('rilproxy.event', 'Event', base.DEC, UNSOL)

all_dissectors = {}

function direction()
    local src_ip = tostring(src_ip_addr_f())
    local dst_ip = tostring(dst_ip_addr_f())

    if (src_ip == ap_ip and dst_ip == bp_ip)
    then
        return DIR_FROM_AP
    end

    if (src_ip == bp_ip and dst_ip == ap_ip)
    then
        return DIR_FROM_BP
    end

    return DIR_UNKNOWN
end

function maybe_unknown(value)
    if value ~= nil
    then
        return value:lower()
    end

    return "unknown"
end

function query_dissector(name)

    name = name:lower()
    if all_dissectors[name] ~= nil
    then
        dissector = Dissector.get(name)
    else
        if missing_dissectors[name]
        then
            missing_dissectors[name] = missing_dissectors[name] + 1
        else
            missing_dissectors[name] = 1
        end
        dissector = Dissector.get("rild.content")
    end

    return dissector
end

function ril_stats_menu()
    local ril_stat_window = TextWindow.new("RIL statistics");
    local text = ''

    text = text .. '<h1>Statistics</h1>'

    text = text .. '<h2>Logs</h2>'

    text = text .. ril_log

    local missing_total = 0
    local missing_unique = 0
    for name, value in pairs(missing_dissectors)
    do
        missing_unique = missing_unique + 1
        missing_total = missing_total + value
    end

    text = text .. '<h2>Missing dissectors</h2>'
    text = text .. missing_unique .. ' unique dissectors missing from ' .. missing_total .. ' packets.'
    text = text .. '<table style="width:100%"><tr>'
    text = text .. '<tr><th>Count</th><th>Dissector</th></tr>'

    for name, value in pairs(missing_dissectors)
    do
        text = text .. '<tr><td>' .. string.format('%3.3d', value) .. '</td><td>' .. name .. '</td></tr>'
    end

    text = text .. '</table>'

    ril_stat_window:set(text)
end

function rilproxy.init()
    cache = ByteArray.new()
    bytesMissing = 0
    subDissector = false
    ap_ip = nil
    bp_ip = nil
    frames = {}
    requests = {}
    missing_dissectors = {}

    for key,value in pairs(Dissector.list())
    do
        all_dissectors[value] = key
    end

    log("Started")
end

function add_default_fields(tree, message, buffer, length)
    local subtree = tree:add(rilproxy, buffer:range(0, length), "RILd, " .. message)
    subtree:add(rilproxy.fields.length, buffer(0,4))
    return subtree
end

function rilproxy.dissector(buffer, info, tree)

    -- Follow-up to a message where length header indicates
    -- more bytes than available in the message.
    if bytesMissing > 0
    then

        if buffer:len() > bytesMissing
        then
            log("[" .. info.number .. "] Follow-up message longer (" .. buffer:len() .. ") than missing bytes (" .. bytesMissing .. "), ignoring")
            bytesMissing = 0
            cache = ByteArray.new()
            return
        end

        cache:append(buffer(0):bytes())
        bytesMissing = bytesMissing - buffer:len()

        -- Still fragments missing, wait for next packet
        if bytesMissing > 0
        then
            return
        end

        buffer = ByteArray.tvb(cache, "Packet")
        cache = nil
    end

    local buffer_len = buffer:len()

    -- Message must be at least 4 bytes
    if buffer_len < 4 then
        log("[" .. info.number .. "] Dropping short buffer of len " .. buffer_len)
        return
    end

    local header_len = buffer:range(0,4):uint()

    if header_len < 4 then
        log("[" .. info.number .. "] Dropping short header len of " .. header_len)
        return
    end

    --  FIXME: Upper limit?
    if header_len > 1492
    then
        log("[" .. info.number .. "] Skipping long buffer of length " .. header_len)
        bytesMissing = 0
        cache = ByteArray.new()
        return
    end

    if buffer_len <= (header_len - 4)
    then
        bytesMissing = header_len - buffer_len + 4
        cache:append(buffer(0):bytes())
        buffer = nil
        return
    end

    cache = ByteArray.new()
    bytesMissing = 0

    local rid = buffer(4,4):le_uint()
    if (rid == REQUEST_SETUP)
    then
        ap_ip = tostring(src_ip_addr_f())
        bp_ip = tostring(dst_ip_addr_f())
    end        

    if subDissector == true
    then
        info.cols.info:append (", ")
    else
        info.cols.info = DirectionLabel[direction()] .. " "
    end

    info.cols.protocol = 'RILProxy'

    if (direction() == DIR_FROM_AP)
    then
        -- Request
        message = "REQUEST(" .. maybe_unknown(REQUEST[rid]) .. ")"
        info.cols.info:append(message)
        subtree = add_default_fields(tree, message, buffer, header_len + 4)
        subtree:add_le(rilproxy.fields.request, buffer(4,4))
        if (header_len > 4)
        then
            token = buffer(8,4):le_uint()
            frames[token] = info.number
            requests[token] = rid
            subtree:add_le(rilproxy.fields.token, buffer(8,4))
        end
        if (header_len > 8)
        then
            dissector = query_dissector("rild.request." .. REQUEST[rid])
            dissector:call(buffer(12, header_len - 12 + 4):tvb(), info, subtree)
        end
    elseif direction() == DIR_FROM_BP
    then
        local mtype = buffer(4,4):le_uint()
        if (mtype == MTYPE_REPLY)
        then
            local result = buffer(12,4):le_uint()
            local token = buffer(8,4):le_uint()
            local rid = requests[token]
            message = "REPLY(" .. maybe_unknown(REQUEST[rid]) ..") = " .. maybe_unknown(ERRNO[result])
            info.cols.info:append(message)
            subtree = add_default_fields(tree, message, buffer, header_len + 4)
            subtree:add_le(rilproxy.fields.mtype, buffer(4,4))
            subtree:add_le(rilproxy.fields.token, buffer(8,4))
            if frames[token] ~= nil
            then
                subtree:add(rilproxy.fields.reply, frames[token])
            end
            subtree:add_le(rilproxy.fields.result, buffer(12,4))
            if (header_len > 12)
            then
                dissector = query_dissector("rild.reply." .. maybe_unknown(REQUEST[rid]))
                dissector:call(buffer(16, header_len - 16 + 4):tvb(), info, subtree)
            end
        elseif (mtype == MTYPE_UNSOL)
        then
            local event = buffer(8,4):le_uint()
            message = "UNSOL(" .. maybe_unknown(UNSOL[event]) .. ")"
            info.cols.info:append(message)
            subtree = add_default_fields(tree, message, buffer, header_len + 4)
            subtree:add_le(rilproxy.fields.mtype, buffer(4,4))
            subtree:add_le(rilproxy.fields.event, buffer(8,4))
            if (header_len > 8)
            then
                dissector = query_dissector("rild.unsol." .. UNSOL[event])
                dissector:call(buffer(12, header_len - 12 + 4):tvb(), info, subtree)
            end
        else
            info.cols.info:append("UNKNOWN REPLY")
        end
    else
        info.cols.info:append("INVALID DIRECTION")
    end


    -- If data is left in buffer, run dissector on it
    if buffer_len > header_len + 4
    then
        local previous = subDissector
        subDissector = true
        rilproxy.dissector (buffer:range(header_len + 4, -1):tvb(), info, tree)
        subDissector = previous
    end
end

local udp_port_table = DissectorTable.get("udp.port")
udp_port_table:add(18912, rilproxy.dissector)

if gui_enabled() then
    register_menu("RIL socket statistics", ril_stats_menu, MENU_STAT_TELEPHONY)
end
