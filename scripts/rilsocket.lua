-- This is Wireshark/tshark packet dissector for RILd messages. Place it into
-- your local plugin directory (e.g. $HOME/.wireshark/plugins/)
--
-- FIXMES:
-- * Use int32 where appropriate

-- Load ril.h definitions generated by scripts/convert_ril_h.py
-- Place the resulting file as ril_h.lua into your plugin directory
local ril_h = require 'ril_h'

-- Inset custom rilproxy requests
REQUEST_SETUP = 0xc715
REQUEST[REQUEST_SETUP] = "SETUP"

REQUEST_TEARDOWN = 0xc717
REQUEST[REQUEST_TEARDOWN] = "TEARDOWN"

local rilproxy = Proto("rild", "RILd socket");
local ril_log = ''

-- Register expert info fields
local rild_error = ProtoExpert.new("rild.error", "Error decoding RIL message", expert.group.MALFORMED, expert.severity.ERROR)
rilproxy.experts = { rild_error }

-----------------------------------------------------------------------------------------------------------------------
-- Helper functions
-----------------------------------------------------------------------------------------------------------------------
function parse_int_list(buffer)
    local result = {}
    assert(buffer:len() > 3)
    local len = buffer:range(0,4):le_uint()
    assert(4 * len + 4 <= buffer:len())
    for i = 1, len
    do
        table.insert(result, buffer:range(4*i, 4):le_uint())
    end
    return result
end

function parse_string(buffer)

    assert(buffer:len() > 3)
    local len = buffer:range(0,4):le_uint()

    --  Null string is represented as len=0xffffffff.
    if len == 0xffffffff
    then
        return 4, nil
    end

    -- The len values stored in the first 4 bytes of the buffer
    -- denotes the length in *characters*. Every character allocates
    -- 2 bytes of space and is stored in little-endian byte order.
    -- The storage size of the string in bytes is rounded up to the
    -- next multiple of 4 bytes such that space is availble for an
    -- additional trailing null-character (2 bytes).
    local string_len = 4 + 4 * math.ceil ((len + 1) / 2)

    assert(string_len <= buffer:len(), "len=" .. len .. ", expectd >= " .. string_len)

    local result = ""
    for i=4,2*len+2,2
    do
        result = result .. string.char(buffer:range(i,2):le_uint())
    end

    return string_len, result
end

function parse_stringlist(buffer)

    assert(buffer:len() > 3)
    local len = buffer:range(0,4):le_uint()
    local start = 4

    results = {}
    for i=1,len
    do
        len, data = parse_string(buffer(start,-1))
        table.insert(results, {len=len, data=data})
        start = start + len
    end
    return results
end

function parse_list(dissector, subtreetext, num, buffer, info, tree)
    local start = 0
    for i = 1,num
    do
        local subtree = tree:add(subtreetext .. " #" .. i)
        start = dissector:call(buffer(start,-1):tvb(), info, subtree)
    end
end

function parse_bytes(buffer)

    assert(buffer:len() > 3)
    local len = buffer:range(0,4):le_uint()
    assert(len <= buffer:len(), "len=" .. buffer:len() .. ", expectd >= " .. len)

    local padded_len = 4 * math.floor((len + 3) / 4) + 4

    return padded_len, buffer:range(4,len)
end

--  Parse a number as a bitfield defined by table
function parse_bitfield(value, table)

    -- Sanity check: values must not overlap
    for outer, unused1 in pairs(table)
    do
        for inner, unused2 in pairs(table)
        do
            assert(inner == outer or (bit32.band(inner, outer) == 0),
                "parse_bitfield: Overlapping values [" .. inner .. "] and [" .. outer .. "]")
        end
    end

    local result = {}
    for entry, name in pairs(table)
    do
        if (bit32.band(value, entry)) > 0
        then
            result[entry] = name
        end
    end

    return result
end

--  Check for known AID values
function parse_aid(value)

    if value == nil
    then
        return '<NULL>'
    end

    value = value:upper()
    result = nil

    --  Values according to
    --      https://source.android.com/devices/tech/config/uicc
    --      https://www.eftlab.co.uk/index.php/site-map/knowledge-base/211-emv-aid-rid-pix
    if value == 'A00000015141434C00'
    then
        result = 'Access Rule Applet'
    elseif value == 'A000000063504B43532D3135'
    then
        result = 'PKCS15'
    elseif value == 'A0000000871002FF49FF0589'
    then
        result = '3GPP USIM'
    else
        result = 'INVALID'
    end

    return result .. ' ("' .. value .. '")'
end

--  Print a table
function table_repr(table)

    if table == nil
    then
        return "<NULL>"
    end

    local num = 0
    local result = ""

    for value, name in pairs(table)
    do
        if num > 0
        then
            result = result .. ", "
        end
        result = result .. name .. " (" .. string.format('%x', value) .. ")"
        num = num + 1
    end

    return result
end

--  Represent nil value as <NULL> string
function nil_repr(value)

    if value == nil
    then
        return '<NULL>'
    end

    return value
end

--  Convert string to int, return 0xffffffff if input is nil
function to_int(text)
    if text == nil
    then
        return 0xffffffff
    end
    return tonumber(text)
end

-- Add an little-endian integer from 'buffer' to a 'field' in 'tree'.
-- The value is addeded only if it is within first..last and does
-- not equal 'invalid'. Otherwise the strings 'INVALID' or 'OUT OF BOUNDS'
-- are added respectively.
function add_le_with_domain(tree, field, buffer, first, last, invalid)
    local value = buffer:le_int()

    if value == invalid
    then
        tree:add(field, buffer, "INVALID (" .. tostring(value) .. ")")
        return
    end

    if value < first or value > last
    then
        tree:add(field, buffer, "OUT OF BOUNDS (" .. tostring(value) .. ")")
        return
    end

    tree:add(field, buffer, tostring(value))
end

function log(message)
    ril_log = ril_log .. message .. "<br>"
end

function update_histogram(table, value)
    if table[value] == nil
    then
        table[value] = 1
    else
        table[value] = table[value] + 1
    end
end

function update_min_max(table, name, value)

    if value == nil
    then
        return
    end

    if table[name] == nil
    then
        table[name] = { min = 0xffffffff, max = 0 }
    end

    if table[name].min > value
    then
        table[name].min = value
    end

    if table[name].max < value
    then
        table[name].max = value
    end
end

function count_table (table)
    count = 0
    for entry in pairs(table)
    do
        count = count + 1
    end
    return count
end

-----------------------------------------------------------------------------------------------------------------------
-- hexdump dissector
-----------------------------------------------------------------------------------------------------------------------
local rild_content = Proto("rild.content", "Hexdump content");

rild_content.fields.content = ProtoField.bytes("rild.hexdump", "Hexdump", base.HEX)

function rild_content.dissector(buffer, info, tree)
    if buffer:len() > 0
    then
        tree:add(rild_content.fields.content, buffer:range(0,-1))
        info.cols.info:append(" *** ")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- UNSOL(RESPONSE_NEW_SMS) dissector
-----------------------------------------------------------------------------------------------------------------------
local unsol_response_new_sms = Proto("rild.unsol.response_new_sms", "RESPONSE_NEW_SMS");

unsol_response_new_sms.fields.data =
    ProtoField.string('rild.unsol_response_new_sms.data', 'Data', base.STRING)

function unsol_response_new_sms.dissector(buffer, info, tree)
    local data_len, data = parse_string(buffer)
    tree:add(unsol_response_new_sms.fields.data, buffer(0,data_len), nil_repr(data))
end

-----------------------------------------------------------------------------------------------------------------------
-- UNSOL(RIL_CONNECTED) dissector
-----------------------------------------------------------------------------------------------------------------------
local unsol_ril_connected = Proto("rild.unsol.ril_connected", "RIL_CONNECTED");

unsol_ril_connected.fields.version = ProtoField.uint32('rild.unsol_ril_connected.version', 'RIL version', base.DEC)

function unsol_ril_connected.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add_le(unsol_ril_connected.fields.version, buffer:range(4,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- UNSOL(RIL_UNSOL_CDMA_PRL_CHANGED) dissector
-----------------------------------------------------------------------------------------------------------------------
local unsol_cdma_prl_changed = Proto("rild.unsol.cdma_prl_changed", "RIL_UNSOL_CDMA_PRL_CHANGED");

unsol_cdma_prl_changed.fields.prlversion =
    ProtoField.uint32('rild.unsol_cdma_prl_changed.prlversion', 'PRL version', base.DEC)

function unsol_cdma_prl_changed.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add_le(unsol_cdma_prl_changed.fields.prlversion, buffer:range(4,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- UNSOL(OEM_HOOK_RAW) dissector
-----------------------------------------------------------------------------------------------------------------------

local unsol_oem_hook_raw = Proto("rild.unsol.oem_hook_raw", "OEM_HOOK_RAW");

unsol_oem_hook_raw.fields.data =
    ProtoField.bytes('rild.unsol.oem_hook_raw.data', 'Data', base.HEX)

function unsol_oem_hook_raw.dissector(buffer, info, tree)
    len, data = parse_bytes(buffer)
    tree:add(unsol_oem_hook_raw.fields.data, buffer:range(0,len))
end

-----------------------------------------------------------------------------------------------------------------------
-- UNSOL(RESPONSE_RADIO_STATE_CHANGED) dissector
-----------------------------------------------------------------------------------------------------------------------

local unsol_response_radio_state_changed = Proto("rild.unsol.response_radio_state_changed", "RESPONSE_RADIO_STATE_CHANGED");

-- According to ril.h, RESPONSE_RADIO_STATE_CHANGED has no data payload.
-- However, older RIL.java sources mention that is "has bonus radio state int" which is casted into RadioState.
-- Try to extract and convert this additional field.
unsol_response_radio_state_changed.fields.version =
    ProtoField.uint32('rild.unsol.response_radio_state_changed.state', 'Radio state', base.DEC, RADIOSTATE)

function unsol_response_radio_state_changed.dissector(buffer, info, tree)
    if buffer:len() > 3
    then
        tree:add_le(unsol_response_radio_state_changed.fields.version, buffer:range(0,4))
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- UNSOL(SIGNAL_STRENGTH) dissector
-----------------------------------------------------------------------------------------------------------------------

local gw_signal_strength = Proto("rild.gw_signal_strength", "GW SignalStrength");

gw_signal_strength.fields.signalstrength =
    ProtoField.string('rild.gw_signal_strength.signalstrength', 'Signal strength', base.DEC)

gw_signal_strength.fields.biterrorrate =
    ProtoField.string('rild.gw_signal_strength.biterrorrate', 'Bit error rate', base.DEC)

function gw_signal_strength.dissector(buffer, info, tree)
    add_le_with_domain(tree, gw_signal_strength.fields.signalstrength, buffer:range(0,4), 0, 31, 99)
    add_le_with_domain(tree, gw_signal_strength.fields.biterrorrate, buffer:range(4,4), 0, 7, 99)
end

-----------------------------------------------------------------------------------------------------------------------

local cdma_signal_strength = Proto("rild.cdma_signal_strength", "CDMA SignalStrength");

cdma_signal_strength.fields.dbm =
    ProtoField.string('rild.cdma_signal_strength.dbm', 'RSSI', base.DEC)

cdma_signal_strength.fields.ecio =
    ProtoField.string('rild.cdma_signal_strength.ecio', 'Ec/Io', base.DEC)

function cdma_signal_strength.dissector(buffer, info, tree)
    add_le_with_domain(tree, cdma_signal_strength.fields.dbm, buffer:range(0,4), 0, 0xfffffffe, 0xffffffff)
    add_le_with_domain(tree, cdma_signal_strength.fields.ecio, buffer:range(4,4), 0, 0xfffffffe, 0xffffffff)
end

-----------------------------------------------------------------------------------------------------------------------

local evdo_signal_strength = Proto("rild.evdo_signal_strength", "EVDO SignalStrength");

evdo_signal_strength.fields.signalnoiseratio =
    ProtoField.string('rild.evdo_signal_strength.signalnoiseratio', 'SNI', base.DEC)

function evdo_signal_strength.dissector(buffer, info, tree)
    cdma_signal_strength.dissector:call(buffer(0,8):tvb(), info, tree)
    add_le_with_domain(tree, evdo_signal_strength.fields.signalnoiseratio, buffer:range(8,4), 0, 8, 0xffffffff)
end

-----------------------------------------------------------------------------------------------------------------------

local lte_signal_strength = Proto("rild.lte_signal_strength", "LTE SignalStrength");

lte_signal_strength.fields.signalstrength =
    ProtoField.string('rild.lte_signal_strength.signalstrength', 'Signal strength', base.DEC)
lte_signal_strength.fields.rsrp =
    ProtoField.string('rild.lte_signal_strength.rsrp', 'RSRP', base.DEC)
lte_signal_strength.fields.rsrq =
    ProtoField.string('rild.lte_signal_strength.rsrq', 'RSRQ', base.DEC)
lte_signal_strength.fields.rssnr =
    ProtoField.string('rild.lte_signal_strength.rssnr', 'RSSNR', base.DEC)
lte_signal_strength.fields.cqi =
    ProtoField.string('rild.lte_signal_strength.cqi', 'CQI', base.DEC)
lte_signal_strength.fields.timingadvance =
    ProtoField.string('rild.lte_signal_strength.timingadvance', 'Timing advance', base.DEC)

function lte_signal_strength.dissector(buffer, info, tree)
    add_le_with_domain(tree, lte_signal_strength.fields.rsrp, buffer:range(0,4), 0, 31, 99)
    add_le_with_domain(tree, lte_signal_strength.fields.rsrp, buffer:range(4,4), 44, 140, 0x7fffffff)
    add_le_with_domain(tree, lte_signal_strength.fields.rsrq, buffer:range(8,4), 3, 20, 0x7fffffff)
    add_le_with_domain(tree, lte_signal_strength.fields.rssnr, buffer:range(12,4), -200, 300, 0x7fffffff)
    add_le_with_domain(tree, lte_signal_strength.fields.cqi, buffer:range(16,4), 0, 15, 0x7fffffff)
end

-----------------------------------------------------------------------------------------------------------------------

local unsol_signal_strength = Proto("rild.unsol.signal_strength", "SIGNAL_STRENGTH");

--
-- There are multiple version of RIL_SignalStrength_v?? type. We can distinguish
-- them by their size:
--
-- RIL_SignalStrength_v5:  28
-- RIL_SignalStrength_v6:  48
-- RIL_SignalStrength_v8:  52
-- RIL_SignalStrength_v10: 56
--

unsol_signal_strength.fields.version =
    ProtoField.uint32('rild.unsol.signal_strength.state', 'Radio state', base.DEC, RADIOSTATE)

unsol_signal_strength.fields.timingadvance =
    ProtoField.string('rild.unsol.signal_strength.timingadvance', 'Timing advance')

unsol_signal_strength.fields.rscp =
    ProtoField.uint32('rild.unsol.signal_strength.rscp', 'Received signal code power', base.DEC)

function unsol_signal_strength.dissector(buffer, info, tree)
    if buffer:len() < 28
    then
        return
    end

    local gw_subtree = tree:add(gw_signal_strength, buffer(0,8))
    gw_signal_strength.dissector:call(buffer(0,8):tvb(), info, gw_subtree)
    local cdma_subtree = tree:add(cdma_signal_strength, buffer(8,8))
    cdma_signal_strength.dissector:call(buffer(8,8):tvb(), info, cdma_subtree)
    local evdo_subtree = tree:add(evdo_signal_strength, buffer(16,12))
    evdo_signal_strength.dissector:call(buffer(16,12):tvb(), info, evdo_subtree)

    if buffer:len() > 28
    then
        local lte_subtree = tree:add(lte_signal_strength, buffer(28,20))
        lte_signal_strength.dissector:call(buffer(28,20):tvb(), info, lte_subtree)

        if buffer:len() > 48
        then
            add_le_with_domain(lte_subtree, unsol_signal_strength.fields.timingadvance, buffer:range(48,4), 0, 0x7ffffffe, 0x7fffffff)

            if buffer:len() > 52
            then
                add_le_with_domain(lte_subtree, unsol_signal_strength.fields.rscp, buffer:range(52,4), 25, 120, 0x7fffffff)
            end
        end
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- UNSOL(RESTRICTED_STATE_CHANGED) dissector
-----------------------------------------------------------------------------------------------------------------------

local unsol_restricted_state_changed = Proto("rild.unsol.restricted_state_changed", "RESTRICTED_STATE_CHANGED");

unsol_restricted_state_changed.fields.state =
    ProtoField.string('rild.unsol.restricted_state_changed.state', 'State', base.String)

function unsol_restricted_state_changed.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add(unsol_restricted_state_changed.fields.state, buffer:range(4,4), table_repr(parse_bitfield(values[1], RESTRICTED_STATE)))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,-1), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- UNSOL(STK_EVENT_NOTIFY) dissector
-----------------------------------------------------------------------------------------------------------------------

local unsol_stk_event_notify = Proto("rild.unsol.stk_event_notify", "STK_EVENT_NOTIFY");

unsol_stk_event_notify.fields.data =
    ProtoField.string('rild.unsol.stk_event_notify.data', 'data', base.String)

function unsol_stk_event_notify.dissector(buffer, info, tree)
    local data_len, data = parse_string(buffer(0,-1))
    tree:add(unsol_stk_event_notify.fields.data, buffer(0, data_len), nil_repr(data))
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(STK_SEND_TERMINAL_RESPONSE) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_stk_send_terminal_response = Proto("rild.request.stk_send_terminal_response", "STK_SEND_TERMINAL_RESPONSE");

request_stk_send_terminal_response.fields.data =
    ProtoField.string('rild.request.stk_send_terminal_response.data', 'data', base.String)

function request_stk_send_terminal_response.dissector(buffer, info, tree)
    local data_len, data = parse_string(buffer(0,-1))
    tree:add(request_stk_send_terminal_response.fields.data, buffer(0, data_len), nil_repr(data))
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(GET_IMSI) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_get_imsi = Proto("rild.request.get_imsi", "REQUEST_GET_IMSI");

request_get_imsi.fields.aid =
    ProtoField.string('rild.request.get_imsi.aid', 'AID', base.String)

function request_get_imsi.dissector(buffer, info, tree)
    results = parse_stringlist(buffer)
    if #results == 1
    then
        start = 4
        tree:add(request_get_imsi.fields.aid, buffer(start, results[1].len), parse_aid(results[1].data))
    else
        tree:add_tvb_expert_info(request_enter_sim_pin.fields.pin, buffer, "Expected string list with 1 element (got " .. #results .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(SMS_ACKNOWLEDGE) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_sms_acknowledge = Proto("rild.request.sms_acknowledge", "SMS_ACKNOWLEDGE");

RECEIPT_FAILED = 0
RECEIPT_SUCCESSFUL = 1

RECEIPT = {
    [RECEIPT_FAILED] = "FAILED",
    [RECEIPT_SUCCESSFUL] = "SUCCESSFUL"
}

FAILURECAUSE_NO_ERROR = 0
FAILURECAUSE_MEMORY_CAPACITY_EXCEEDED = 0xde
FAILURECAUSE_UNSPECIFIED_ERROR = 0xff

FAILURECAUSE = {
    [FAILURECAUSE_NO_ERROR] = "NO_ERROR",
    [FAILURECAUSE_MEMORY_CAPACITY_EXCEEDED] = "MEMORY_CAPACITY_EXCEEDED",
    [FAILURECAUSE_UNSPECIFIED_ERROR] = "UNSPECIFIED_ERROR"
}

request_sms_acknowledge.fields.receipt =
    ProtoField.uint32('rild.request.sms_acknowledge.receipt', 'Receipt', base.DEC, RECEIPT)

request_sms_acknowledge.fields.failurecause =
    ProtoField.uint32('rild.request.sms_acknowledge.failurecause', 'Failure cause', base.DEC, FAILURECAUSE)

function request_sms_acknowledge.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 2
    then
        tree:add_le(request_sms_acknowledge.fields.receipt, buffer:range(4,4))
        tree:add_le(request_sms_acknowledge.fields.failurecause, buffer:range(8,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 2 elements (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(RADIO_POWER) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_radio_power = Proto("rild.request.radio_power", "REQUEST_RADIO_POWER");

-- FIXME: 'on' actually means > 0
RADIO_POWER = {
    [0] = "OFF",
    [1] = "ON"
}

request_radio_power.fields.power =
    ProtoField.uint32('rild.request.radio_power.power', 'Radio power', base.DEC, RADIO_POWER)

function request_radio_power.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add(request_radio_power.fields.power, buffer:range(4,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(ENTER_SIM_PIN) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_enter_sim_pin = Proto("rild.request.enter_sim_pin", "REQUEST_ENTER_SIM_PIN");

request_enter_sim_pin.fields.pin =
    ProtoField.string('rild.request.enter_sim_pin.pin', 'PIN', base.STRING)

request_enter_sim_pin.fields.aid =
    ProtoField.string('rild.request.enter_sim_pin.aid', 'AID', base.STRING)

function request_enter_sim_pin.dissector(buffer, info, tree)
    results = parse_stringlist(buffer)
    if #results == 2
    then
        start = 4
        tree:add(request_enter_sim_pin.fields.pin, buffer(start, results[1].len), nil_repr(results[1].data))
        start = start + results[1].len
        tree:add(request_enter_sim_pin.fields.aid, buffer(start, results[2].len), parse_aid(results[2].data))
        start = start + results[1].len
    else
        tree:add_tvb_expert_info(request_enter_sim_pin.fields.pin, buffer, "Expected string list with 2 element (got " .. #results .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(QUERY_FACILITY_LOCK) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_query_facility_lock = Proto("rild.request.query_facility_lock", "REQUEST_QUERY_FACILITY_LOCK");

request_query_facility_lock.fields.facility =
    ProtoField.string('rild.request.query_facility_lock.facility', 'Facility', base.STRING)

request_query_facility_lock.fields.password =
    ProtoField.string('rild.request.query_facility_lock.password', 'Password', base.STRING)


--  Service class according to ETSI TS 127 007 V13.3.0, 7.4 Facility lock +CLCK
SERVICECLASS_VOICE = 1
SERVICECLASS_DATA = 2
SERVICECLASS_FAX = 4
SERVICECLASS_SMS = 8
SERVICECLASS_DATA_CIRCUIT_SYNC = 16
SERVICECLASS_DATA_CIRCUIT_ASYNC = 32
SERVICECLASS_DEDICATED_PACKET_ACCESS = 64
SERVICECLASS_DEDICATED_PAD_ACCESS = 128

SERVICECLASS = {
    [SERVICECLASS_VOICE] = "VOICE",
    [SERVICECLASS_DATA] = "DATA",
    [SERVICECLASS_FAX] = "FAX",
    [SERVICECLASS_SMS] = "SMS",
    [SERVICECLASS_DATA_CIRCUIT_SYNC] = "DATA_CIRCUIT_SYNC",
    [SERVICECLASS_DATA_CIRCUIT_ASYNC] = "DATA_CIRCUIT_ASYNC",
    [SERVICECLASS_DEDICATED_PACKET_ACCESS] = "DEDICATED_PACKET_ACCESS",
    [SERVICECLASS_DEDICATED_PAD_ACCESS] = "DEDICATED_PAD_ACCESS"
}

request_query_facility_lock.fields.class =
    ProtoField.string('rild.request.query_facility_lock.class', 'Service class', base.DEC)

request_query_facility_lock.fields.aid =
    ProtoField.string('rild.request.query_facility_lock.aid', 'AID', base.STRING)

function request_query_facility_lock.dissector(buffer, info, tree)
    results = parse_stringlist(buffer)
    if #results == 4
    then
        start = 4
        tree:add(request_query_facility_lock.fields.facility, buffer(start, results[1].len), nil_repr(results[1].data))
        start = start + results[1].len
        tree:add(request_query_facility_lock.fields.password, buffer(start, results[2].len), nil_repr(results[2].data))
        start = start + results[2].len
        tree:add(request_query_facility_lock.fields.class, buffer(start, results[3].len),
            table_repr(parse_bitfield(results[3].data, SERVICECLASS)))
        start = start + results[3].len
        tree:add(request_query_facility_lock.fields.aid, buffer(start, results[4].len), parse_aid(results[4].data))
        start = start + results[4].len
    else
        tree:add_tvb_expert_info(request_query_facility_lock.fields.pin, buffer, "Expected string list with 4 elements (got " .. #results .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(SCREEN_STATE) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_screen_state = Proto("rild.request.screen_state", "REQUEST_SCREEN_STATE");

SCREEN_STATE = {
    [0] = "OFF",
    [1] = "ON"
}

request_screen_state.fields.screenstate =
    ProtoField.uint32('rild.request.screen_state.screenstate', 'Screen state', base.DEC, SCREEN_STATE)

function request_screen_state.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add_le(request_screen_state.fields.screenstate, buffer:range(4,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(SIM_OPEN_CHANNEL) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_sim_open_channel = Proto("rild.request.sim_open_channel", "REQUEST_SIM_OPEN_CHANNEL");

request_sim_open_channel.fields.aid_len =
    ProtoField.uint32('rild.request.sim_open_channel.aid_len', 'Length', base.DEC)

request_sim_open_channel.fields.aid =
    ProtoField.string('rild.request.sim_open_channel.aid', 'Value', base.STRING)

function request_sim_open_channel.dissector(buffer, info, tree)
    local len, value = parse_string(buffer)
    subtree:add(request_sim_open_channel.fields.aid, buffer(0, len), parse_aid(value))
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(CDMA_SET_SUBSCRIPTION_SOURCE) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_cdma_set_subscription_source = Proto("rild.request.cdma_set_subscription_source", "REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE");

request_cdma_set_subscription_source.fields.subscription =
    ProtoField.uint32('rild.request.cdma_set_subscription_source.fields.subscription', 'Subscription source', base.DEC, CDMASUBSCRIPTIONSOURCE)

function request_cdma_set_subscription_source.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add(request_cdma_set_subscription_source.fields.subscription, buffer:range(4,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(SET_PREFERRED_NETWORK_TYPE) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_set_preferred_network_type =
    Proto("rild.request.set_preferred_network_type", "REQUEST_SET_PREFERRED_NETWORK_TYPE");

request_set_preferred_network_type.fields.preferrednetworktype =
    ProtoField.uint32('rild.request.set_preferred_network_type.fields.preferrednetworktype', 'Preferred network type',
        base.DEC, PREFERREDNETWORKTYPE)

function request_set_preferred_network_type.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add(request_set_preferred_network_type.fields.preferrednetworktype, buffer:range(4,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(ALLOW_DATA) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_allow_data =
    Proto("rild.request.allow_data", "ALLOW_DATA");

DATAALLOWED_ALLOWED = 0
DATAALLOWED_DISALLOWED = 1

DATAALLOWED = {
    [DATAALLOWED_ALLOWED] = "ALLOWED",
    [DATAALLOWED_DISALLOWED] = "DISALLOWED"
}

request_allow_data.fields.dataallowed =
    ProtoField.int32('rild.request.allow_data.fields.dataallowed', 'Data', base.DEC, DATAALLOWED)

function request_allow_data.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add(request_allow_data.fields.dataallowed, buffer:range(4,4):le_int())
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(SET_UNSOL_CELL_INFO_LIST_RATE) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_set_unsol_cell_info_list_rate = Proto("rild.request.set_unsol_cell_info_list_rate", "SET_UNSOL_CELL_INFO_LIST_RATE");

request_set_unsol_cell_info_list_rate.fields.rate_ms =
    ProtoField.uint32('rild.request.set_unsol_cell_info_list_rate.fields.rate_ms', 'Rate [ms]', base.DEC)
request_set_unsol_cell_info_list_rate.fields.rate =
    ProtoField.string('rild.request.set_unsol_cell_info_list_rate.fields.rate', 'Rate')

function request_set_unsol_cell_info_list_rate.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        if (values[1] == 0)
        then
            -- Invoke UNSOL(CELL_INFO_LIST) when information changes
            tree:add(request_set_unsol_cell_info_list_rate.fields.rate, buffer:range(4,4), "ON CHANGE")
        elseif (values[1] == 0x7fffffff)
        then
            -- Never invoke UNSOL(CELL_INFO_LIST)
            tree:add(request_set_unsol_cell_info_list_rate.fields.rate, buffer:range(4,4), "NEVER")
        else
            -- Invoke UNSOL(CELL_INFO_LIST) every n milli-seconds
            tree:add_le(request_set_unsol_cell_info_list_rate.fields.rate_ms, buffer:range(4,4))
        end
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(START_LCE) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_start_lce = Proto("rild.request.start_lce", "REQUEST_START_LCE");

request_start_lce.fields.reportinginterval =
    ProtoField.uint32('rild.request.start_lce.fields.reportinginterval', 'Reporting interval [ms]', base.DEC)

LCE_SERVICE_MODE_PUSH = 0
LCE_SERVICE_MODE_PULL = 1

LCE_SERVICE_MODE = {
    [LCE_SERVICE_MODE_PUSH] = "PUSH",
    [LCE_SERVICE_MODE_PULL] = "PULL"
}

request_start_lce.fields.servicemode =
    ProtoField.uint32('rild.request.start_lce.fields.servicemode', 'Service mode', base.DEC, LCE_SERVICE_MODE)

function request_start_lce.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 2
    then
        tree:add(request_start_lce.fields.reportinginterval, buffer:range(4,4), values[1])
        tree:add(request_start_lce.fields.servicemode, buffer:range(8,4), values[2])
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 2 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REQUEST(SIM_IO) dissector
-----------------------------------------------------------------------------------------------------------------------

local request_sim_io = Proto("rild.request.sim_io", "REQUEST_SIM_IO");

CRSMCOMMAND_READ_BINARY = 176
CRSMCOMMAND_READ_RECORD = 178
CRSMCOMMAND_GET_RESPONSE = 192
CRSMCOMMAND_UPDATE_BINARY = 214
CRSMCOMMAND_UPDATE_RECORD = 220
CRSMCOMMAND_STATUS = 242
CRSMCOMMAND_RETRIEVE_DATA = 203
CRSMCOMMAND_SET_DATA = 219

CRSMCOMMAND = {
    [CRSMCOMMAND_READ_BINARY]   = "READ_BINARY",
    [CRSMCOMMAND_READ_RECORD]   = "READ_RECORD",
    [CRSMCOMMAND_GET_RESPONSE]  = "GET_RESPONSE",
    [CRSMCOMMAND_UPDATE_BINARY] = "UPDATE_BINARY",
    [CRSMCOMMAND_UPDATE_RECORD] = "UPDATE_RECORD",
    [CRSMCOMMAND_STATUS]        = "STATUS",
    [CRSMCOMMAND_RETRIEVE_DATA] = "RETRIEVE_DATA",
    [CRSMCOMMAND_SET_DATA]      = "SET_DATA"
}

request_sim_io.fields.command =
    ProtoField.uint32('rild.request.sim_io.fields.command', 'Command', base.DEC, CRSMCOMMAND)

request_sim_io.fields.fileid =
    ProtoField.uint32('rild.request.sim_io.fields.file_id', 'File ID', base.HEX)

request_sim_io.fields.path =
    ProtoField.string('rild.request.sim_io.fields.path', 'Path', base.STRING)

request_sim_io.fields.p1 =
    ProtoField.uint32('rild.request.sim_io.fields.p1', 'P1', base.HEX)

request_sim_io.fields.p2 =
    ProtoField.uint32('rild.request.sim_io.fields.p2', 'P2', base.HEX)

request_sim_io.fields.p3 =
    ProtoField.uint32('rild.request.sim_io.fields.p3', 'P3', base.HEX)

request_sim_io.fields.data =
    ProtoField.string('rild.request.sim_io.fields.data', 'Data', base.STRING)

request_sim_io.fields.pin2 =
    ProtoField.string('rild.request.sim_io.fields.pin2', 'PIN2', base.STRING)

request_sim_io.fields.aid =
    ProtoField.string('rild.request.sim_io.fields.aid', 'AID', base.STRING)

function request_sim_io.dissector(buffer, info, tree)
    tree:add_le(request_sim_io.fields.command, buffer:range(0,4))
    tree:add_le(request_sim_io.fields.fileid, buffer:range(4,4))

    local path_len, path = parse_string(buffer(8,-1))
    tree:add(request_sim_io.fields.path, buffer(8, path_len), '"' .. nil_repr(path) .. '"')

    local path_end = 8 + path_len
    tree:add_le(request_sim_io.fields.p1, buffer:range(path_end,4))
    tree:add_le(request_sim_io.fields.p2, buffer:range(path_end + 4,4))
    tree:add_le(request_sim_io.fields.p3, buffer:range(path_end + 8,4))

    local data_len, data = parse_string(buffer(path_end + 12,-1))
    tree:add(request_sim_io.fields.data, buffer(path_end + 12, data_len), '"' .. nil_repr(data) .. '"')

    local data_end = path_end + 12 + data_len
    local pin2_len, pin2 = parse_string(buffer(data_end, -1))
    tree:add(request_sim_io.fields.data, buffer(data_end, pin2_len), '"' .. nil_repr(pin2) .. '"')

    local pin2_end = data_end + pin2_len
    if pin2_end + 4 <= buffer:len()
    then
        local aid_len, aid = parse_string(buffer(pin2_end, -1))
        tree:add(request_sim_io.fields.aid, buffer(pin2_end, aid_len), parse_aid(aid))
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(DATA_REGISTRATION_STATE) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_data_registration_state = Proto("rild.reply.data_registration_state", "REPLY_DATA_REGISTRATION_STATE");

reply_data_registration_state.fields.regstate =
    ProtoField.uint32('rild.reply.data_registration_state.regstate', 'Registration state', base.DEC, REGSTATE)

reply_data_registration_state.fields.lac =
    ProtoField.string('rild.reply.data_registration_state.lac', 'LAC', base.STRING)

reply_data_registration_state.fields.cid =
    ProtoField.string('rild.reply.data_registration_state.cid', 'CID', base.STRING)

reply_data_registration_state.fields.rat =
    ProtoField.uint32('rild.reply.data_registration_state.rat', 'RAT', base.DEC, RADIOTECHNOLOGY)

-- FIXME: Not used at the moment. Convert strings to numeric values.
DATA_DENIED_REASON_GPRS_SERVICE_NOT_ALLOWED = 7
DATA_DENIED_REASON_GPRS_SERVICE_AND_NON_GPRS_SERVICE_NOT_ALLOWED = 8
DATA_DENIED_REASON_MS_IDENTITY_CANNOT_BE_DERIVED = 9
DATA_DENIED_REASON_IMPLICITLY_DETACHED = 10
DATA_DENIED_REASON_GPRS_SERVICE_NOT_ALLOWED_IN_THIS_PLMN = 14
DATA_DENIED_REASON_MSC_TEMPORARILY_NOT_REACHABLE = 16
DATA_DENIED_REASON_NO_PDP_CONTEXT_ACTIVATED = 40

DATA_DENIED_REASON = {
    [DATA_DENIED_REASON_GPRS_SERVICE_NOT_ALLOWED] = "GPRS services not allowed",
    [DATA_DENIED_REASON_GPRS_SERVICE_AND_NON_GPRS_SERVICE_NOT_ALLOWED] = "GPRS services and non-GPRS services not allowed",
    [DATA_DENIED_REASON_MS_IDENTITY_CANNOT_BE_DERIVED] = "MS identity cannot be derived by the network",
    [DATA_DENIED_REASON_IMPLICITLY_DETACHED] = "Implicitly detached",
    [DATA_DENIED_REASON_GPRS_SERVICE_NOT_ALLOWED_IN_THIS_PLMN] = "GPRS services not allowed in this PLMN",
    [DATA_DENIED_REASON_MSC_TEMPORARILY_NOT_REACHABLE] = "MSC temporarily not reachable",
    [DATA_DENIED_REASON_NO_PDP_CONTEXT_ACTIVATED] = "No PDP context activated"
}

reply_data_registration_state.fields.reasondatadenied =
    ProtoField.uint32('rild.reply.data_registration_state.reasondatadenied', 'Data-denied reason', base.DEC, DATA_DENIED_REASON)

reply_data_registration_state.fields.maxdatacalls =
    ProtoField.uint32('rild.reply.data_registration_state.maxdatacalls', 'Maximum data calls', base.DEC)

reply_data_registration_state.fields.ltetac =
    ProtoField.string('rild.reply.data_registration_state.ltetac', 'LTE TAC', base.STRING)

reply_data_registration_state.fields.ltecid =
    ProtoField.string('rild.reply.data_registration_state.ltecid', 'LTE CID', base.STRING)

reply_data_registration_state.fields.lteeci =
    ProtoField.string('rild.reply.data_registration_state.lteeci', 'LTE ECI', base.STRING)

reply_data_registration_state.fields.ltecsgid =
    ProtoField.string('rild.reply.data_registration_state.ltecsgid', 'LTE CSGID', base.STRING)

reply_data_registration_state.fields.ltetadv =
    ProtoField.string('rild.reply.data_registration_state.ltetadv', 'LTE TADV', base.STRING)

function reply_data_registration_state.dissector(buffer, info, tree)
    local results = parse_stringlist(buffer)
    if #results >= 6
    then
        start = 4
        tree:add(reply_data_registration_state.fields.regstate, buffer(start, results[1].len), to_int(results[1].data))
        start = start + results[1].len
        tree:add(reply_data_registration_state.fields.lac, buffer(start, results[2].len), nil_repr(results[2].data))
        start = start + results[2].len
        tree:add(reply_data_registration_state.fields.cid, buffer(start, results[3].len), nil_repr(results[3].data))
        start = start + results[3].len
        tree:add(reply_data_registration_state.fields.rat, buffer(start, results[4].len), to_int(results[4].data))
        start = start + results[4].len
        tree:add(reply_data_registration_state.fields.reasondatadenied, buffer(start, results[5].len), to_int(results[5].data))
        start = start + results[5].len
        tree:add(reply_data_registration_state.fields.maxdatacalls, buffer(start, results[6].len), to_int(results[6].data))

        if #results >= 11
        then
            start = start + results[6].len
            tree:add(reply_data_registration_state.fields.ltetac, buffer(start, results[7].len), nil_repr(results[7].data))
            start = start + results[7].len
            tree:add(reply_data_registration_state.fields.ltecid, buffer(start, results[8].len), nil_repr(results[8].data))
            start = start + results[8].len
            tree:add(reply_data_registration_state.fields.lteeci, buffer(start, results[9].len), nil_repr(results[9].data))
            start = start + results[9].len
            tree:add(reply_data_registration_state.fields.ltecsgid, buffer(start, results[10].len), nil_repr(results[10].data))
            start = start + results[10].len
            tree:add(reply_data_registration_state.fields.ltetadv, buffer(start, results[11].len), nil_repr(results[11].data))
        end
    else
        tree:add_tvb_expert_info(reply_data_registration_state.fields.regstate, buffer, "Expected string list with 11 element (got " .. #results .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(VOICE_REGISTRATION_STATE) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_voice_registration_state = Proto("rild.reply.voice_registration_state", "REPLY_VOICE_REGISTRATION_STATE");

reply_voice_registration_state.fields.regstate =
    ProtoField.uint32('rild.reply.voice_registration_state.regstate', 'Registration state', base.DEC, REGSTATE)

reply_voice_registration_state.fields.rat =
    ProtoField.uint32('rild.reply.voice_registration_state.rat', 'RAT', base.DEC, RADIOTECHNOLOGY)

CSS_UNSUPPORTED = 0
CSS_SUPPORTED = 1
CSS_NOT_APPLICABLE = 0xffffffff

CSS = {
    [CSS_UNSUPPORTED] = "UNSUPPORTED",
    [CSS_SUPPORTED] = "SUPPORTED",
    [CSS_NOT_APPLICABLE] = "N/A"
}

reply_voice_registration_state.fields.csssupported =
    ProtoField.uint32('rild.reply.voice_registration_state.csssupported', 'Concurrent services', base.DEC, CSS)

reply_voice_registration_state.fields.roamingindicator =
    ProtoField.uint32('rild.reply.voice_registration_state.roamingindicator', 'Roaming indicator', base.DEC)

INPRL_NOT_INPRL = 0
INPRL_INPRL = 1
INPRL_NOT_APPLICABLE = 0xffffffff

INPRL = {
    [INPRL_NOT_INPRL] = "NOT IN PRL",
    [INPRL_INPRL] = "IN PRL",
    [INPRL_NOT_APPLICABLE] = "N/A"
}

reply_voice_registration_state.fields.systemisinprl =
    ProtoField.uint32('rild.reply.voice_registration_state.systemisinprl', 'Roaming indicator', base.DEC, INPRL)

reply_voice_registration_state.fields.defaultroamingindicator =
    ProtoField.uint32('rild.reply.voice_registration_state.defaultroamingindicator', 'Default roaming indicator', base.DEC)

REASONFORDENIAL_GENERAL = 0
REASONFORDENIAL_AUTHENTICATION_FAILURE = 1
REASONFORDENIAL_IMSI_UNKNOWN_IN_HLR = 2
REASONFORDENIAL_ILLEGAL_MS = 3
REASONFORDENIAL_ILLEGAL_ME = 4
REASONFORDENIAL_PLMN_NOT_ALLOWED = 5
REASONFORDENIAL_LOCATION_AREA_NOT_ALLOWED = 6
REASONFORDENIAL_ROAMING_NOT_ALLOWED = 7
REASONFORDENIAL_NO_SUITABLE_CELLS_IN_THIS_LOCATION_AREA = 8
REASONFORDENIAL_NETWORK_FAILURE = 9
REASONFORDENIAL_PERSISTENT_LOCATION_UPDATE_REJECT = 10
REASONFORDENIAL_PLMN_NOT_ALLOWED = 11
REASONFORDENIAL_LOCATION_AREA_NOT_ALLOWED = 12
REASONFORDENIAL_ROAMING_NOT_ALLOWED_IN_THIS_LOCATION_AREA = 13
REASONFORDENIAL_NO_SUITABLE_CELLS_IN_THIS_LOCATION_AREA = 15
REASONFORDENIAL_NETWORK_FAILURE = 17
REASONFORDENIAL_MAC_FAILURE = 20
REASONFORDENIAL_SYNC_FAILURE = 21
REASONFORDENIAL_CONGESTION = 22
REASONFORDENIAL_GSM_AUTHENTICATION_UNACCEPTABLE = 23
REASONFORDENIAL_NOT_AUTHORIZED_FOR_THIS_CSG = 25
REASONFORDENIAL_SERVICE_OPTION_NOT_SUPPORTED = 32
REASONFORDENIAL_REQUESTED_SERVICE_OPTION_NOT_SUBSCRIBED = 33
REASONFORDENIAL_SERVICE_OPTION_TEMPORARILY_OUT_OF_ORDER = 34
REASONFORDENIAL_CALL_CANNOT_BE_IDENTIFIED = 38
REASONFORDENIAL_SEMANTICALLY_INCORRECT_MESSAGE = 95
REASONFORDENIAL_INVALID_MANDATORY_INFORMATION = 96
REASONFORDENIAL_MESSAGE_TYPE_NON_EXISTENT_OR_NOT_IMPLEMENTED = 97
REASONFORDENIAL_MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 98
REASONFORDENIAL_INFORMATION_ELEMENT_NON_EXISTENT_OR_NOT_IMPLEMENTED = 99
REASONFORDENIAL_CONDITIONAL_IE_ERROR = 100
REASONFORDENIAL_MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 101
REASONFORDENIAL_NOT_APPLICABLE = 0xffffffff

REASONFORDENIAL = {
    [REASONFORDENIAL_GENERAL] = "GENERAL",
    [REASONFORDENIAL_AUTHENTICATION_FAILURE] = "AUTHENTICATION_FAILURE",
    [REASONFORDENIAL_IMSI_UNKNOWN_IN_HLR] = "IMSI_UNKNOWN_IN_HLR",
    [REASONFORDENIAL_ILLEGAL_MS] = "ILLEGAL_MS",
    [REASONFORDENIAL_ILLEGAL_ME] = "ILLEGAL_ME",
    [REASONFORDENIAL_PLMN_NOT_ALLOWED] = "PLMN_NOT_ALLOWED",
    [REASONFORDENIAL_LOCATION_AREA_NOT_ALLOWED] = "LOCATION_AREA_NOT_ALLOWED",
    [REASONFORDENIAL_ROAMING_NOT_ALLOWED] = "ROAMING_NOT_ALLOWED",
    [REASONFORDENIAL_NO_SUITABLE_CELLS_IN_THIS_LOCATION_AREA] = "NO_SUITABLE_CELLS_IN_THIS_LOCATION_AREA",
    [REASONFORDENIAL_NETWORK_FAILURE] = "NETWORK_FAILURE",
    [REASONFORDENIAL_PERSISTENT_LOCATION_UPDATE_REJECT] = "PERSISTENT_LOCATION_UPDATE_REJECT",
    [REASONFORDENIAL_PLMN_NOT_ALLOWED] = "PLMN_NOT_ALLOWED",
    [REASONFORDENIAL_LOCATION_AREA_NOT_ALLOWED] = "LOCATION_AREA_NOT_ALLOWED",
    [REASONFORDENIAL_ROAMING_NOT_ALLOWED_IN_THIS_LOCATION_AREA] = "ROAMING_NOT_ALLOWED_IN_THIS_LOCATION_AREA",
    [REASONFORDENIAL_NO_SUITABLE_CELLS_IN_THIS_LOCATION_AREA] = "NO_SUITABLE_CELLS_IN_THIS_LOCATION_AREA",
    [REASONFORDENIAL_NETWORK_FAILURE] = "NETWORK_FAILURE",
    [REASONFORDENIAL_MAC_FAILURE] = "MAC_FAILURE",
    [REASONFORDENIAL_SYNC_FAILURE] = "SYNC_FAILURE",
    [REASONFORDENIAL_CONGESTION] = "CONGESTION",
    [REASONFORDENIAL_GSM_AUTHENTICATION_UNACCEPTABLE] = "GSM_AUTHENTICATION_UNACCEPTABLE",
    [REASONFORDENIAL_NOT_AUTHORIZED_FOR_THIS_CSG] = "NOT_AUTHORIZED_FOR_THIS_CSG",
    [REASONFORDENIAL_SERVICE_OPTION_NOT_SUPPORTED] = "SERVICE_OPTION_NOT_SUPPORTED",
    [REASONFORDENIAL_REQUESTED_SERVICE_OPTION_NOT_SUBSCRIBED] = "REQUESTED_SERVICE_OPTION_NOT_SUBSCRIBED",
    [REASONFORDENIAL_SERVICE_OPTION_TEMPORARILY_OUT_OF_ORDER] = "SERVICE_OPTION_TEMPORARILY_OUT_OF_ORDER",
    [REASONFORDENIAL_CALL_CANNOT_BE_IDENTIFIED] = "CALL_CANNOT_BE_IDENTIFIED",
    [REASONFORDENIAL_SEMANTICALLY_INCORRECT_MESSAGE] = "SEMANTICALLY_INCORRECT_MESSAGE",
    [REASONFORDENIAL_INVALID_MANDATORY_INFORMATION] = "INVALID_MANDATORY_INFORMATION",
    [REASONFORDENIAL_MESSAGE_TYPE_NON_EXISTENT_OR_NOT_IMPLEMENTED] = "MESSAGE_TYPE_NON_EXISTENT_OR_NOT_IMPLEMENTED",
    [REASONFORDENIAL_MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE] = "MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE",
    [REASONFORDENIAL_INFORMATION_ELEMENT_NON_EXISTENT_OR_NOT_IMPLEMENTED] = "INFORMATION_ELEMENT_NON_EXISTENT_OR_NOT_IMPLEMENTED",
    [REASONFORDENIAL_CONDITIONAL_IE_ERROR] = "CONDITIONAL_IE_ERROR",
    [REASONFORDENIAL_MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE] = "MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE",
    [REASONFORDENIAL_NOT_APPLICABLE] = "N/A",
}

--  48-63 - Retry upon entry into a new cell
for e = 48, 64
do
    REASONFORDENIAL[e] = "RETRY_UPON_ENTRY_INTO_A_NEW_CELL"
end

reply_voice_registration_state.fields.reasonfordenial =
    ProtoField.uint32('rild.reply.voice_registration_state.reasonfordenial', 'Reason for denial', base.DEC, REASONFORDENIAL)

reply_voice_registration_state.fields.cellinfotype =
    ProtoField.uint32('rild.reply.voice_registration_state.cellinfotype', 'Cell info type', base.DEC, CELLINFOTYPE)

function reply_voice_registration_state.dissector(buffer, info, tree)
    local results = parse_stringlist(buffer)
    if #results >= 8
    then
        start = 4
        tree:add(reply_voice_registration_state.fields.regstate, buffer(start, results[1].len), to_int(results[1].data))
        start = start + results[1].len
        tree:add(reply_voice_registration_state.fields.rat, buffer(start, results[2].len), to_int(results[2].data))
        start = start + results[2].len
        tree:add(reply_voice_registration_state.fields.csssupported, buffer(start, results[3].len), to_int(results[3].data))
        start = start + results[3].len
        tree:add(reply_voice_registration_state.fields.roamingindicator, buffer(start, results[4].len), to_int(results[4].data))
        start = start + results[4].len
        tree:add(reply_voice_registration_state.fields.systemisinprl, buffer(start, results[5].len), to_int(results[5].data))
        start = start + results[5].len
        tree:add(reply_voice_registration_state.fields.defaultroamingindicator, buffer(start, results[6].len), to_int(results[6].data))
        start = start + results[6].len
        tree:add(reply_voice_registration_state.fields.reasonfordenial, buffer(start, results[7].len), to_int(results[7].data))
        start = start + results[7].len
        tree:add(reply_voice_registration_state.fields.cellinfotype, buffer(start, results[8].len), to_int(results[8].data))
        start = start + results[8].len
    else
        tree:add_tvb_expert_info(reply_voice_registration_state.fields.regstate, buffer, "Expected string list with 2 element (got " .. #results .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(QUERY_NETWORK_SELECTION_MODE) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_query_network_selection_mode = Proto("rild.reply.query_network_selection_mode", "QUERY_NETWORK_SELECTION_MODE");

SELECTION_AUTOMATIC = 0
SELECTION_MANUAL = 1
SELECTION = {
    [SELECTION_AUTOMATIC] = "AUTOMATIC",
    [SELECTION_MANUAL] = "MANUAL"
}

reply_query_network_selection_mode.fields.selection =
    ProtoField.uint32('rild.reply.reply_query_network_selection_mode.selection', 'Selection mode', base.DEC, SELECTION)

function reply_query_network_selection_mode.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add_le(reply_query_network_selection_mode.fields.selection, buffer:range(4,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(QUERY_FACILITY_LOCK) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_query_facility_lock = Proto("rild.reply.query_facility_lock", "REPLY_QUERY_FACILITY_LOCK");

reply_query_facility_lock.fields.barringactive =
    ProtoField.string('rild.reply.reply_query_facility_lock.barringactive', 'Barring', base.STRING)

function reply_query_facility_lock.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        value = buffer:range(4,4):le_int()
        if value == 0
        then
            result = "disable for all"
        else
            result = "active for " .. table_repr(parse_bitfield(value, SERVICECLASS))
        end
        tree:add_le(reply_query_facility_lock.fields.barringactive, buffer:range(4,4), result)
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(BASEBAND_VERSION) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_baseband_version = Proto("rild.reply.baseband_version", "BASEBAND_VERSION");

reply_baseband_version.fields.version =
    ProtoField.string('rild.reply.reply_baseband_version.version', 'Baseband version', base.STRING)

function reply_baseband_version.dissector(buffer, info, tree)
    local len, string = parse_string(buffer)
    tree:add(reply_baseband_version.fields.version, buffer:range(0, len), '"' .. nil_repr(string) .. '"')
end
-----------------------------------------------------------------------------------------------------------------------
-- REPLY(OPERATOR) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_operator = Proto("rild.reply.operator", "OPERATOR");

reply_operator.fields.long_alpha_ons =
    ProtoField.string('rild.reply.reply_operator.long_alpha_ons', 'Long alpha ONS or EONS', base.STRING)

reply_operator.fields.short_alpha_ons =
    ProtoField.string('rild.reply.reply_operator.short_alpha_ons', 'Short alpha ONS or EONS', base.STRING)

reply_operator.fields.mcc_mnc =
    ProtoField.string('rild.reply.reply_operator.mcc_mnc', 'MCC/MNC', base.STRING)

function reply_operator.dissector(buffer, info, tree)
    local results = parse_stringlist(buffer)
    tree:add(reply_operator.fields.long_alpha_ons, buffer(4, results[1].len), nil_repr(results[1].data))
    tree:add(reply_operator.fields.short_alpha_ons, buffer(4 + results[1].len, results[2].len), nil_repr(results[2].data))
    tree:add(reply_operator.fields.mcc_mnc, buffer(4 + results[1].len + results[2].len, results[3].len), nil_repr(results[3].data))
    -- FIXME: The traces I saw had 6 strings - investigate what the remaining 3 are good for.
end


-----------------------------------------------------------------------------------------------------------------------
-- REPLY(GET_IMEI) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_get_imei = Proto("rild.reply.get_imei", "GET_IMEI");

reply_get_imei.fields.imei =
    ProtoField.string('rild.reply.reply_get_imei.imei', 'IMEI', base.STRING)

function reply_get_imei.dissector(buffer, info, tree)
    local len, string = parse_string(buffer)
    tree:add(reply_get_imei.fields.imei, buffer:range(0, len), '"' .. nil_repr(string) .. '"')
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(GET_IMEISV) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_get_imeisv = Proto("rild.reply.get_imeisv", "GET_IMEISV");

reply_get_imeisv.fields.imeisv =
    ProtoField.string('rild.reply.reply_get_imeisv.imeisv', 'IMEISV', base.STRING)

function reply_get_imeisv.dissector(buffer, info, tree)
    local len, string = parse_string(buffer)
    tree:add(reply_get_imeisv.fields.imeisv, buffer:range(0, len), '"' .. nil_repr(string) .. '"')
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(GET_IMSI) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_get_imsi = Proto("rild.reply.get_imsi", "REPLY_GET_IMSI");

reply_get_imsi.fields.imei =
    ProtoField.string('rild.reply.reply_get_imsi.imei', 'IMSI', base.STRING)

function reply_get_imsi.dissector(buffer, info, tree)
    local len, string = parse_string(buffer)
    tree:add(reply_get_imsi.fields.imei, buffer:range(0, len), '"' .. nil_repr(string) .. '"')
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(START_LCE) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_start_lce = Proto("rild.reply.start_lce", "START_LCE");

LCE_STATUS_INFO_NOT_SUPPORTED = 255
LCE_STATUS_INFO_STOPPED = 0
LCE_STATUS_INFO_ACTIVE = 1

LCE_STATUS_INFO = {
    [LCE_STATUS_INFO_NOT_SUPPORTED] = "NOT SUPPORTED",
    [LCE_STATUS_INFO_STOPPED] = "STOPPED",
    [LCE_STATUS_INFO_ACTIVE] = "ACTIVE"
}

reply_start_lce.fields.status=
    ProtoField.uint32('rild.reply.start_lce.status', 'Status', base.DEC, LCE_STATUS_INFO)

reply_start_lce.fields.interval =
    ProtoField.uint32('rild.reply.start_lce.interval', 'Actual interval [ms]', base.DEC)

function reply_start_lce.dissector(buffer, info, tree)
    tree:add_le(reply_start_lce.fields.status, buffer:range(0, 4))
    tree:add_le(reply_start_lce.fields.interval, buffer:range(4, 4))
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(VOICE_RADIO_TECH) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_voice_radio_tech = Proto("rild.reply.voice_radio_tech", "VOICE_RADIO_TECH");

reply_voice_radio_tech.fields.radiotechnology =
    ProtoField.uint32('rild.reply.reply_voice_radio_tech.radiotechnology', 'Radio technology', base.DEC, RADIOTECHNOLOGY)

function reply_voice_radio_tech.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add_le(reply_voice_radio_tech.fields.radiotechnology, buffer:range(4,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(ENTER_SIM_PIN) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_enter_sim_pin = Proto("rild.reply.enter_sim_pin", "REPLY_ENTER_SIM_PIN");

reply_enter_sim_pin.fields.numberofretriesleft =
    ProtoField.int32('rild.reply.reply_enter_sim_pin.numberofretriesleft', 'Number of retries left', base.DEC)

function reply_enter_sim_pin.dissector(buffer, info, tree)
    local values = parse_int_list(buffer)
    if #values == 1
    then
        tree:add_le(reply_enter_sim_pin.fields.numberofretriesleft, buffer:range(4,4))
    else
        tree:add_tvb_expert_info(rild_error, buffer:range(0,4), "Expected integer list with 1 element (got " .. #values .. ")")
    end
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(SIM_IO) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_sim_io = Proto("rild.reply.sim_io", "SIM_IO");

reply_sim_io.fields.sw1 =
    ProtoField.uint32('rild.reply.reply_sim_io.sw1', 'SW1', base.DEC)

reply_sim_io.fields.sw2 =
    ProtoField.uint32('rild.reply.reply_sim_io.sw2', 'SW2', base.DEC)

reply_sim_io.fields.simresponse =
    ProtoField.string('rild.reply.reply_sim_io.simresponse', 'SIM response', base.STRING)

function reply_sim_io.dissector(buffer, info, tree)
    tree:add_le(reply_sim_io.fields.sw1, buffer:range(0,4))
    tree:add_le(reply_sim_io.fields.sw2, buffer:range(4,4))

    response_len, response = parse_string(buffer(8,-1))
    tree:add(reply_sim_io.fields.simresponse, buffer:range(8,response_len), nil_repr(response))
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(GET_SIM_STATUS) dissector
-----------------------------------------------------------------------------------------------------------------------

local app_status = Proto("rild.app_status", "AppStatus")

app_status.fields.apptype =
    ProtoField.uint32('rild.app_status.apptype', 'App type', base.DEC, APPTYPE)

app_status.fields.appstate =
    ProtoField.uint32('rild.app_status.appstate', 'App state', base.DEC, APPSTATE)

app_status.fields.persosubstate =
    ProtoField.uint32('rild.app_status.persosubstate', 'Perso substate', base.DEC, PERSOSUBSTATE)

app_status.fields.aid =
    ProtoField.string('rild.app_status.aid', 'AID', base.STRING)

app_status.fields.applabel =
    ProtoField.string('rild.app_status.applabel', 'App label', base.STRING)

app_status.fields.pin1replaced =
    ProtoField.int32('rild.app_status.pin1replaced', 'PIN1 replaced', base.DEC)

app_status.fields.pin1state =
    ProtoField.uint32('rild.app_status.pin1state', 'PIN1 state', base.DEC, PINSTATE)

app_status.fields.pin2state =
    ProtoField.uint32('rild.app_status.pin2state', 'PIN2 state', base.DEC, PINSTATE)

function app_status.dissector(buffer, info, tree)
    tree:add_le(app_status.fields.apptype, buffer:range(0,4))
    tree:add_le(app_status.fields.appstate, buffer:range(4,4))
    tree:add_le(app_status.fields.persosubstate, buffer:range(8,4))
    aidlen, aid = parse_string(buffer(12,-1))
    tree:add(app_status.fields.aid, buffer:range(12,aidlen), parse_aid(aid))

    applabelstart = 12 + aidlen
    applabellen, applabel = parse_string(buffer(applabelstart,-1))
    tree:add(app_status.fields.applabel, buffer:range(applabelstart, applabellen), nil_repr(applabel))

    p1rstart = applabelstart + applabellen
    tree:add_le(app_status.fields.pin1replaced, buffer:range(p1rstart,4))
    tree:add_le(app_status.fields.pin1state, buffer:range(p1rstart + 4,4))
    tree:add_le(app_status.fields.pin2state, buffer:range(p1rstart + 8,4))
    return p1rstart + 12
end

-----------------------------------------------------------------------------------------------------------------------

local reply_get_sim_status = Proto("rild.reply.get_sim_status", "GET_SIM_STATUS");

reply_get_sim_status.fields.cardstate =
    ProtoField.uint32('rild.reply.reply_get_sim_status.cardstate', 'Card state', base.DEC, CARDSTATE)

reply_get_sim_status.fields.pinstate =
    ProtoField.uint32('rild.reply.reply_get_sim_status.pinstate', 'PIN state', base.DEC, PINSTATE)

reply_get_sim_status.fields.gsmumtssubscriptionappindex =
    ProtoField.int32('rild.reply.reply_get_sim_status.gsmumtssubscriptionappindex', 'GSM/UMTS subscription app index', base.DEC)

reply_get_sim_status.fields.cdmasubscriptionappindex =
    ProtoField.int32('rild.reply.reply_get_sim_status.cdmasubscriptionappindex', 'CDMA subscription app index', base.DEC)

reply_get_sim_status.fields.imssubscriptionappindex =
    ProtoField.int32('rild.reply.reply_get_sim_status.imssubscriptionappindex', 'IMS subscription app index', base.DEC)

reply_get_sim_status.fields.numapplications =
    ProtoField.int32('rild.reply.reply_get_sim_status.numapplications', 'Number of applications', base.DEC)

function reply_get_sim_status.dissector(buffer, info, tree)
    tree:add_le(reply_get_sim_status.fields.cardstate, buffer:range(0,4))
    tree:add_le(reply_get_sim_status.fields.pinstate, buffer:range(4,4))
    tree:add_le(reply_get_sim_status.fields.gsmumtssubscriptionappindex, buffer:range(8,4))
    tree:add_le(reply_get_sim_status.fields.cdmasubscriptionappindex, buffer:range(12,4))
    tree:add_le(reply_get_sim_status.fields.imssubscriptionappindex, buffer:range(16,4))
    tree:add_le(reply_get_sim_status.fields.numapplications, buffer:range(20,4))

    num_apps = buffer:range(20,4):le_int()
    parse_list(app_status.dissector, "App status", num_apps, buffer:range(24,-1), info, tree)
end

-----------------------------------------------------------------------------------------------------------------------
-- REPLY(GET_RADIO_CAPABILITY) dissector
-----------------------------------------------------------------------------------------------------------------------

local reply_get_radio_capability = Proto("rild.reply.get_radio_capability", "GET_RADIO_CAPABILITY");

reply_get_radio_capability.fields.version =
    ProtoField.uint32('rild.reply.reply_get_radio_capability.version', 'Version', base.DEC)

reply_get_radio_capability.fields.session =
    ProtoField.uint32('rild.reply.reply_get_radio_capability.session', 'Session', base.DEC)

reply_get_radio_capability.fields.phase =
    ProtoField.uint32('rild.reply.reply_get_radio_capability.phase', 'Phase', base.DEC, RADIOCAPABILITYPHASE)

reply_get_radio_capability.fields.rat =
    ProtoField.string('rild.reply.reply_get_radio_capability.rat', 'RAT', base.STRING)

reply_get_radio_capability.fields.logicalmodemuuid =
    ProtoField.string('rild.reply.reply_get_radio_capability.logicalmodemuuid', 'Logical modem UUID', base.STRING)

reply_get_radio_capability.fields.status =
    ProtoField.uint32('rild.reply.reply_get_radio_capability.status', 'Status', base.DEC, RADIOCAPABILITYSTATUS)

function reply_get_radio_capability.dissector(buffer, info, tree)
    tree:add_le(reply_get_radio_capability.fields.version, buffer:range(0,4))
    tree:add_le(reply_get_radio_capability.fields.session, buffer:range(4,4))
    tree:add_le(reply_get_radio_capability.fields.phase, buffer:range(8,4))

    local rat = buffer:range(12,4):le_int()
    tree:add(reply_get_radio_capability.fields.rat, buffer:range(12,4), table_repr(parse_bitfield(rat, RADIOACCESSFAMILY)))

    lmuuid_len, lmuuid = parse_string(buffer(16,-1))
    tree:add(reply_get_radio_capability.fields.logicalmodemuuid, buffer:range(16,lmuuid_len), nil_repr(lmuuid))
    tree:add_le(reply_get_radio_capability.fields.status, buffer:range(16 + lmuuid_len,4))
end

-----------------------------------------------------------------------------------------------------------------------
-- RILd dissector
-----------------------------------------------------------------------------------------------------------------------
local src_ip_addr_f = Field.new("ip.src")
local dst_ip_addr_f = Field.new("ip.dst")

MTYPE_REPLY = 0
MTYPE_UNSOL = 1

MTYPE = {
    [MTYPE_REPLY] = "REPLY",
    [MTYPE_UNSOL] = "UNSOL"
}

DIR_UNKNOWN = 0
DIR_FROM_AP = 1
DIR_FROM_BP = 2

DirectionLabel = {
    [DIR_UNKNOWN] = "[??->??]",
    [DIR_FROM_AP] = "[AP->BP]",
    [DIR_FROM_BP] = "[BP->AP]"
}

rilproxy.fields.length  = ProtoField.uint32('rild.length', 'Length', base.DEC)
rilproxy.fields.request = ProtoField.uint32('rild.request', 'Request', base.DEC, REQUEST)
rilproxy.fields.mtype   = ProtoField.uint32('rild.mtype', 'Type', base.DEC, MTYPE)
rilproxy.fields.token   = ProtoField.uint32('rild.token', 'Token', base.HEX)
rilproxy.fields.reply   = ProtoField.framenum('rild.reply', 'In reply to frame', base.NONE, frametype.RESPONSE)
rilproxy.fields.result  = ProtoField.uint32('rild.result', 'Result', base.DEC, ERRNO)
rilproxy.fields.event   = ProtoField.uint32('rild.event', 'Event', base.DEC, UNSOL)

all_dissectors = {}

function direction()
    local src_ip = tostring(src_ip_addr_f())
    local dst_ip = tostring(dst_ip_addr_f())

    if (src_ip == ap_ip and dst_ip == bp_ip)
    then
        return DIR_FROM_AP
    end

    if (src_ip == bp_ip and dst_ip == ap_ip)
    then
        return DIR_FROM_BP
    end

    return DIR_UNKNOWN
end

function maybe_unknown(value)
    if value ~= nil
    then
        return value:lower()
    end

    return "unknown"
end

function query_dissector(name)

    name = name:lower()
    if all_dissectors[name] ~= nil
    then
        dissector = Dissector.get(name)
    else
        update_histogram (missing_dissectors, name)
        dissector = Dissector.get("rild.content")
    end

    return dissector
end

function ril_stats_menu()
    local ril_stat_window = TextWindow.new("RIL statistics");
    local text = ''

    text = text .. '<h1>Statistics</h1>'

    text = text .. '<h2>Request statistics</h2>'

    text = text .. '<table style="width:100%">'
    text = text .. '<tr><th>Name</th><th>Min</th><th>Max</th></tr>'

    table.sort(statistics)
    for name, stat in pairs(statistics)
    do
        text = text .. '<tr><td>' .. name .. '</td><td>&nbsp;' .. stat.min .. '</td><td>' .. stat.max .. '</td></tr>'
    end
    text = text .. '</table>'

    local missing_total = 0
    local missing_unique = 0
    for name, value in pairs(missing_dissectors)
    do
        missing_unique = missing_unique + 1
        missing_total = missing_total + value
    end

    text = text .. '<h2>Missing dissectors</h2>'
    text = text .. missing_unique .. ' unique dissectors missing from ' .. missing_total .. ' packets.'
    text = text .. '<table style="width:100%">'
    text = text .. '<tr><th>Count</th><th>Dissector</th></tr>'

    for name, value in pairs(missing_dissectors)
    do
        text = text .. '<tr><td>' .. string.format('%3.3d', value) .. '</td><td>' .. name .. '</td></tr>'
    end

    text = text .. '</table>'

    text = text .. '<h2>Logs</h2>'

    text = text .. ril_log

    ril_stat_window:set(text)
end

function rilproxy.init()
    cache = ByteArray.new()
    bytesMissing = 0
    subDissector = false
    ap_ip = nil
    bp_ip = nil
    frames = {}
    requests = {}
    pending_requests = {}
    missing_dissectors = {}
    request_num = 0
    last_token = 0
    statistics = {}

    for key,value in pairs(Dissector.list())
    do
        all_dissectors[value] = key
    end

    log("Started")
end

function add_default_fields(tree, message, buffer, length)
    local subtree = tree:add(rilproxy, buffer:range(0, length), "RILd, " .. message)
    subtree:add(rilproxy.fields.length, buffer(0,4))
    return subtree
end

function rilproxy.dissector(buffer, info, tree)

    update_min_max (statistics, "Buffer length (raw)", buffer:len())

    -- Follow-up to a message where length header indicates
    -- more bytes than available in the message.
    if bytesMissing > 0
    then

        cache:append(buffer(0):bytes())
        bytesMissing = bytesMissing - buffer:len()

        -- Still fragments missing, wait for next packet
        if bytesMissing > 0
        then
            return
        end

        buffer = ByteArray.tvb(cache, "Packet")
        cache = nil
    end

    update_min_max (statistics, "Buffer length (reassembled)", buffer_len)

    -- Advance request counter
    request_num = request_num + 1

    local buffer_len = buffer:len()

    -- Message must be at least 4 bytes
    if buffer_len < 4 then
        log("[" .. info.number .. "] Dropping short buffer of len " .. buffer_len)
        return 0
    end

    local header_len = buffer:range(0,4):uint()

    update_min_max (statistics, "Header length (raw)", header_len)

    if header_len < 4 then
        log("[" .. info.number .. "] Dropping short header len of " .. header_len)
        return 0
    end

    --  FIXME: Upper limit?
    if header_len > 3000
    then
        log("[" .. info.number .. "] Skipping long buffer of length " .. header_len)
        bytesMissing = 0
        cache = ByteArray.new()
        return 0
    end

    update_min_max (statistics, "Header length", header_len)

    if buffer_len <= (header_len - 4)
    then
        bytesMissing = header_len - buffer_len + 4
        cache:append(buffer(0):bytes())
        buffer = nil
        return
    end

    cache = ByteArray.new()
    bytesMissing = 0

    local rid = buffer(4,4):le_uint()
    if (rid == REQUEST_SETUP)
    then
        ap_ip = tostring(src_ip_addr_f())
        bp_ip = tostring(dst_ip_addr_f())
    end

    if subDissector == true
    then
        info.cols.info:append (", ")
    else
        info.cols.info = DirectionLabel[direction()] .. " "
    end

    info.cols.protocol = 'RILProxy'

    if (direction() == DIR_FROM_AP)
    then
        -- Request
        message = "REQUEST(" .. maybe_unknown(REQUEST[rid]) .. ")"
        info.cols.info:append(message)
        subtree = add_default_fields(tree, message, buffer(0,-1), header_len + 4)
        subtree:add_le(rilproxy.fields.request, buffer(4,4))
        if (header_len > 4)
        then
            token = buffer(8,4):le_uint()
            info.cols.info:append(" [" .. token .. "]")
            frames[token] = info.number
            requests[token] = { rid = rid, request_num = request_num }
            pending_requests[token] = 1
            subtree:add_le(rilproxy.fields.token, buffer(8,4))

            if token - last_token > 0
            then
                update_min_max (statistics, "Token delta", token - last_token)
            end
            last_token = token
        end
        if (header_len > 8)
        then
            dissector = query_dissector("rild.request." .. maybe_unknown(REQUEST[rid]))
            dissector:call(buffer(12, header_len - 12 + 4):tvb(), info, subtree)
        end
    elseif direction() == DIR_FROM_BP
    then
        local mtype = buffer(4,4):le_uint()
        if (mtype == MTYPE_REPLY)
        then
            local result = buffer(12,4):le_uint()
            local token = buffer(8,4):le_uint()
            local request = requests[token]
            local request_delta = request_num - request.request_num

            pending_requests[token] = nil
            update_min_max (statistics, "Packets until reply", request_delta)

            message = "REPLY(" .. maybe_unknown(REQUEST[request.rid]) ..") [" .. token .. "] = " .. maybe_unknown(ERRNO[result])
            info.cols.info:append(message)
            subtree = add_default_fields(tree, message, buffer, header_len + 4)
            subtree:add_le(rilproxy.fields.mtype, buffer(4,4))
            subtree:add_le(rilproxy.fields.token, buffer(8,4))
            if frames[token] ~= nil
            then
                subtree:add(rilproxy.fields.reply, frames[token])
            end
            subtree:add_le(rilproxy.fields.result, buffer(12,4))
            if (header_len > 12)
            then
                dissector = query_dissector("rild.reply." .. maybe_unknown(REQUEST[request.rid]))
                dissector:call(buffer(16, header_len - 16 + 4):tvb(), info, subtree)
            end
        elseif (mtype == MTYPE_UNSOL)
        then
            local event = buffer(8,4):le_uint()
            message = "UNSOL(" .. maybe_unknown(UNSOL[event]) .. ")"
            info.cols.info:append(message)
            subtree = add_default_fields(tree, message, buffer, header_len + 4)
            subtree:add_le(rilproxy.fields.mtype, buffer(4,4))
            subtree:add_le(rilproxy.fields.event, buffer(8,4))
            if (header_len > 8)
            then
                dissector = query_dissector("rild.unsol." .. UNSOL[event])
                dissector:call(buffer(12, header_len - 12 + 4):tvb(), info, subtree)
            end
        else
            info.cols.info:append("UNKNOWN REPLY")
        end
    else
        info.cols.info:append("INVALID DIRECTION")
    end

    update_min_max (statistics, "In-flight requests", count_table (pending_requests))

    -- If data is left in buffer, run dissector on it
    if buffer_len > header_len + 4
    then
        local previous = subDissector
        subDissector = true
        rilproxy.dissector (buffer:range(header_len + 4, -1):tvb(), info, tree)
        subDissector = previous
    end
end

local udp_port_table = DissectorTable.get("udp.port")
udp_port_table:add(18912, rilproxy.dissector)

if gui_enabled() then
    register_menu("RIL socket statistics", ril_stats_menu, MENU_STAT_TELEPHONY)
end
